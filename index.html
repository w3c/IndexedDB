<!DOCTYPE html>
<html lang='en-US'>
  <head>
    <meta http-equiv='Content-Type' content='text/html; charset=UTF-8'/>
    <title>Indexed Database API (Second Edition)</title>

    <script type="disabled">
    // flatten out interface members so respec will error check links
    window.addEventListener('DOMContentLoaded', function() {
      [].slice.call(document.querySelectorAll('dl.idl > dd')).forEach(function(dd) {
        var dl = dd.parentNode;
        var pos = dl.nextSibling;
        var parent = dl.parentNode;
        var p = document.createElement('p');
        p.innerHTML = dd.innerHTML;
        dd.innerHTML = '';
        parent.insertBefore(p, pos);
      });
    });
    </script>

    <script src='//www.w3.org/Tools/respec/respec-w3c-common' class='remove' async></script>
    <script class='remove'>
      var respecConfig = {
          specStatus:           "ED",

          shortName:            "IndexedDB",

          publishDate:          "2015-06-05",

          previousPublishDate:  "2015-01-08",
          previousMaturity:     "TR",

          edDraftURI:           "https://w3c.github.io/IndexedDB/",

          // editors, add as many as you like
          // only "name" is required
          editors:  [
              { name: "Ali Alabbas", url: "mailto:alia@microsoft.com", company: "Microsoft" },
              { name: "Joshua Bell", url: "mailto:jsbell@google.com", company: "Google" }
          ],

          implementationReportURI: 'http://w3c.github.io/test-results/IndexedDB/all.html',
          testSuiteURI: 'https://github.com/w3c/web-platform-tests/tree/master/IndexedDB',

          maxTocLevel: 3,

          wg:           "Web Applications Working Group",

          wgURI:        "http://www.w3.org/2008/webapps/",

          wgPublicList: "public-webapps",

          wgPatentURI:  "http://www.w3.org/2004/01/pp-impl/42538/status",

          noIDLSectionTitle: true,
      };
    </script>

    <style type="text/css">
      table {
        border-collapse: collapse;
        border-style: hidden hidden none;
      }
      table thead {
        border-bottom: medium solid;
      }
      table td, table th {
        border-bottom: thin solid;
        border-left: medium solid;
        border-right: medium solid;
        padding: 0.2em;
        vertical-align: top;
      }
      .example .example .example-title {
          display: none
      }

      /* Make spec narrower */
      body { max-width: 60em; margin: 0 auto !important; line-height: 1.45; }

      /* Bump up code size */
      code { font-size: 16px !important; }
      pre, pre code { font-size: 14px !important; }

      /* Reduce vertical space */
      .note, .issue { padding: 0em 1.2em !important; }
      .note-title, .issue-title { float: left; min-width: 0 !important; }

       /* Switch statement */
      dl.switch dt::before {
        content: "↪ ";
        margin-left: 1em;
      }
    </style>
  </head>

  <body>
    <section id="abstract">
      <p>
        This document defines APIs for a database of records holding simple values
        and hierarchical objects. Each record consists of a key and some value.
        Moreover, the database maintains indexes over records it stores. An
        application developer directly uses an API to locate records either by
        their key or by using an index. A query language can be layered on this
        API. An indexed database can be implemented using a persistent B-tree data
        structure.
      </p>
    </section>

    <section id='sotd'>
      <p>
        This is the Second Edition of Indexed Database API. The
        <a href="http://www.w3.org/TR/IndexedDB/">First Edition</a>
        became a W3C Recommendation on 8 January 2015.
      </p>
      <p>
        This specification's bugs and issues are managed in
        <a href="https://github.com/w3c/IndexedDB/">GitHub</a>
        (<a href="https://github.com/w3c/IndexedDB/issues/new">new bug</a>,
        <a href="https://github.com/w3c/IndexedDB/issues/">open bugs</a>).
        Feature requests are tracked in the
        <a href="http://www.w3.org/2008/webapps/wiki/IndexedDatabaseFeatures">Indexed Database Features</a> document.
      </p>
    </section>

    <section id='introduction' class='section informative'>
      <h2>Introduction</h2>

      <p>
        User agents need to store large numbers of objects locally in
        order to satisfy off-line data requirements of Web applications.
        [[WEBSTORAGE]] is useful for
        storing pairs of keys and their corresponding values. However, it does
        not provide in-order retrieval of keys, efficient searching over
        values, or storage of duplicate values for a key.
      </p>

      <p>
        This specification provides a concrete API to perform advanced key-value data management
        that is at the heart of most sophisticated query processors. It does
        so by using transactional databases to store keys and their
        corresponding values (one or more per key), and providing a means
        of traversing keys in a deterministic order. This is often implemented
        through the use of persistent B-tree data structures that are considered
        efficient for insertion and deletion as well as in-order traversal of
        very large numbers of data records.
      </p>

      <aside class="example">
          <p>
              In the following example, the API is used to access a "library"
              database that holds books stored by their "isbn" attribute. Additionally,
              an index is maintained on the "title" attribute of the objects
              stored in the object store. This index can be used to look up books
              by title, and enforces a uniqueness constraint. Another index is
              maintained on the "author" attribute of the objects, and can be used
              to look up books by author.
          </p>
          <p>
              A connection to the database is opened. If the "library" database
              did not already exist, it is created and an event handler creates
              the object store and indexes. Finally, the opened connection is
              saved for use in subsequent examples.
          </p>
          <pre class="example highlight">
var request = indexedDB.open("library");

request.onupgradeneeded = function() {
  // The database did not previously exist, so create object stores and indexes.
  var db = request.result;
  var store = db.createObjectStore("books", {keyPath: "isbn"});
  var titleIndex = store.createIndex("by_title", "title", {unique: true});
  var authorIndex = store.createIndex("by_author", "author");

  // Populate with initial data.
  store.put({title: "Quarry Memories", author: "Fred", isbn: 123456});
  store.put({title: "Water Buffaloes", author: "Fred", isbn: 234567});
  store.put({title: "Bedrock Nights", author: "Barney", isbn: 345678});
};

request.onsuccess = function() {
  db = request.result;
};
          </pre>

          <p>
              The following example populates the
              database using a transaction.
          </p>
          <pre class="example highlight">
var tx = db.transaction("books", "readwrite");
var store = tx.objectStore("books");

store.put({title: "Quarry Memories", author: "Fred", isbn: 123456});
store.put({title: "Water Buffaloes", author: "Fred", isbn: 234567});
store.put({title: "Bedrock Nights", author: "Barney", isbn: 345678});

tx.oncomplete = function() {
  // All requests have succeeded and the transaction has committed.
};
          </pre>

          <p>
              The following example looks up a single book in the database
              by title using an index.
          </p>
        <pre class="example highlight">
var tx = db.transaction("books", "readonly");
var store = tx.objectStore("books");
var index = store.index("by_title");

var request = index.get("Bedrock Nights");
request.onsuccess = function() {
  var matching = request.result;
  if (matching !== undefined) {
    // A match was found.
    report(matching.isbn, matching.title, matching.author);
  } else {
    // No match was found.
    report(null);
  }
};
        </pre>

          <p>
              The following example looks up all books
              in the database by author using an index and a cursor.
          </p>
        <pre class="example highlight">
var tx = db.transaction("books", "readonly");
var store = tx.objectStore("books");
var index = store.index("by_author");

var request = index.openCursor(IDBKeyRange.only("Fred"));
request.onsuccess = function() {
  var cursor = request.result;
  if (cursor) {
    // Called for each matching record.
    report(cursor.value.isbn, cursor.value.title, cursor.value.author);
    cursor.continue();
  } else {
    // No more matching records.
    report(null);
  }
};
        </pre>

          <p>
              The following example shows how errors could be handled when
              a request fails.
          </p>
        <pre class="example highlight">
var tx = db.transaction("books", "readwrite");
var store = tx.objectStore("books");
var request = store.put({title: "Water Buffaloes", author: "Slate", isbn: 987654});
request.onerror = function() {
  // The uniqueness constraint of the "by_title" index failed.
  report(request.error);
  // Could call request.preventDefault() to prevent the transaction from aborting.
};
tx.onabort = function() {
  // Otherwise the transaction will automatically abort due the failed request.
  report(tx.error);
};
        </pre>

          <p>
              The database connection may be closed when it is no longer needed.
          </p>
        <pre class="example highlight">
db.close();
        </pre>

        <p>
            In the future, the database may have grown to contain other object
            stores and indexes. The following example shows one way to handle
            opening an older version of the database.
        </p>

          <pre class="example highlight">
var request = indexedDB.open("library", 3); // Request version 3.

request.onupgradeneeded = function(event) {
  var db = request.result;
  if (event.oldVersion &lt; 1) {
    // Version 1 is the first version of the database.
    var store = db.createObjectStore("books", {keyPath: "isbn"});
    var titleIndex = store.createIndex("by_title", "title", {unique: true});
    var authorIndex = store.createIndex("by_author", "author");
  }
  if (event.oldVersion &lt; 2) {
    // Version 2 introduces a new index of books by year.
    var bookStore = request.transaction.objectStore("books");
    var yearIndex = bookStore.createIndex("by_year", "year");
  }
  if (event.oldVersion &lt; 3) {
    // Version 3 introduces a new object store for magazines with two indexes.
    var magazines = db.createObjectStore("magazines");
    var publisherIndex = magazines.createIndex("by_publisher", "publisher");
    var frequencyIndex = magazines.createIndex("by_frequency", "frequency");
  }
};

request.onsuccess = function() {
  db = request.result; // db.version will be 3.
};
          </pre>

      </aside>

    </section>

    <section id='conformance' class='section'>
      <p>
        This specification defines one class of products:
      </p>
      <dl>
        <dt><dfn title="conforming user agent">Conforming user agent</dfn></dt>
        <dd>
          <p>
            A user agent MUST behave as described in this specification
            in order to be considered conformant.
          </p>

          <p>
            User agents MAY implement algorithms given in this
            specification in any way desired, so long as the end result is
            indistinguishable from the result that would be obtained by the
            specification's algorithms.
          </p>

          <p>
            A conforming Indexed Database API user agent MUST also be a
            <em>conforming implementation</em> of the IDL fragments
            of this specification, as described in the
            “Web IDL” specification. [[!WEBIDL]]
          </p>

          <aside class="note">
            This specification uses both the terms "conforming user agent(s)"
            and "user agent(s)" to refer to this product class.
          </aside>
        </dd>
      </dl>

      <section class="section" id="dependencies">
        <h3>Dependencies</h3>
        <p>
          This specification relies on several other underlying specifications.
        </p>
        <dl>
          <dt>DOM-LEVEL-3-EVENTS</dt>
          <dd>The terms <dfn>default action</dfn> and <dfn>propagation path</dfn>
            are defined by the
            Document Object Model (DOM) Level 3 Events Specification [[!DOM-LEVEL-3-EVENTS]].
          </dd>
          <dt>DOM4</dt>
          <dd>The types
            <dfn><code>Event</code></dfn>,
            <dfn><code>EventTarget</code></dfn> and
            <dfn><code>DOMStringList</code></dfn>
            are defined by the W3C DOM4 Specification [[!DOM4]].
          </dd>
          <dt>HTML5</dt>
          <dd>The terms and algorithms
            <dfn>document</dfn>,
            <dfn id="document-base-url">document base URL</dfn>,
            <dfn id="event-handler-attributes">event handler attributes</dfn>,
            <dfn id="event-handler-event-type">event handler event type</dfn>,
            <dfn><code>Function</code></dfn>,
            <dfn>strictly split a string</dfn>,
            <dfn>origin</dfn>, <dfn>same origin</dfn>, <dfn>structured clone</dfn>,
            <dfn>structured clone algorithm</dfn>, <dfn>task</dfn>, <dfn>task source</dfn>,
            and <dfn>queue a task</dfn> are defined by the HTML 5
            specification [[!HTML5]].
          </dd>
          <dt>WebIDL</dt>
          <dd>
            The terms, types, and algorithms
            <dfn>throw</dfn>,
            <dfn>getting a copy of the bytes held by a buffer source</dfn>,
            <dfn>octet</dfn>,
            <dfn>unrestricted double</dfn>,
            <dfn>DOMString</dfn>,
            <dfn>sequence&lt;DOMString&gt;</dfn>,
            <dfn><code>DOMException</code></dfn> and
            and the interface definition language used in this spec
            are defined by [[!WEBIDL]].</dd>
          <dt>WebWorkers</dt>
          <dd>The terms
            <dfn>Worker</dfn> and
            <dfn><code>WorkerUtils</code></dfn>
            are defined by the WebWorkers specification [[!WEBWORKERS]].</dd>
        </dl>
      </section>
    </section>


    <section id="database-api" class="section">
      <h2>Indexed Database API</h2>
      <section id="infrastructure" class="section">
        <p>
          A <dfn>sorted list</dfn> is a <a>DOMStringList</a> containing strings sorted in ascending order using the
          algorithm defined by step 4 of <cite>section 11.8.5, The Abstract Relational Comparison Algorithm</cite>
          of the ECMAScript Language Specification [[!ECMA-262]].
        </p>
      </section>

      <section id="constructs" class="section">
      <h3>Constructs</h3>
       <section id="database-concept" class="section">
          <h4>Database</h4>
          <p>
            A database's <a>origin</a> is the same as the <a>origin</a> of the <a>document</a> or <a>worker</a>.
            Each <a>origin</a> has an associated set of databases.
          </p>
          <aside class="note">The database origin is not affected by changes to <code>document.domain</code>.
	  </aside>
          <p>
            Each <a>origin</a> has an associated set of
            <a title="database">databases</a>. A <dfn>database</dfn> has
            zero or more <a title="object store">object stores</a> which hold the data stored
            in the database.
          </p>
          <p>
            A <a>database</a> has a <dfn title="database name">name</dfn> which identifies it within a specific <a>origin</a>.
            The name can be any string value, including the empty string, and stays constant for the lifetime of the database.
            Database names are always compared in a case-sensitive manner, as opaque sequences of 16-bit code units.
            Implementations MUST support all names.
          </p>
          <aside class="note">
            If an implementation
            uses a storage mechanism which can't handle arbitrary database names,
            the implementation must use an escaping mechanism or something similar
            to map the provided name to a name that it can handle.
          </aside>
          <p>
            A <a>database</a> has a
            <dfn>version</dfn>. When a database is first created, its <a>version</a> is 0 (zero).
          </p>
          <aside class="note">
            Each <a>database</a> has one version at a time; a <a>database</a>
            can't exist in multiple versions at once. The only way to change the version is using an
            <a>upgrade transaction</a>.
          </aside>
          <p>
            A database has a <dfn>delete pending flag</dfn> which is used during deletion. When a database is requested
            to be deleted the flag is set and all attempts at opening the database are stalled until the database
            can be deleted.
          </p>

          <section>
            <h5>Database Connection</h5>
            <p>
              Script does not interact with <a title="database">databases</a> directly. Instead,
              script has indirect access via a <dfn>connection</dfn>.

              A <a>connection</a> object can be used to manipulate the
              objects of that <a>database</a>. It is also the only way to
              obtain a <a>transaction</a> for that <a>database</a>.
            </p>
            <p>
              The act of opening a <a>database</a> creates a <a>connection</a>. There MAY be multiple
              <a title="connection">connections</a> to a given <a>database</a> at any given time.
            </p>
            <p>
              A <a>connection</a> has a <dfn title="connection version">version</dfn>, which is
              set when the <a>connection</a> is created. It remains constant
              for the lifetime of the <a>connection</a> unless an
              <a title="steps for aborting an upgrade transaction">upgrade is aborted</a>, in
              which case it is set to the previous version of the <a>database</a>. Once
              the <a>connection</a> is closed the <a title="connection version">version</a>
              does not change.
            </p>
            <p>
              Each connection has a
              <dfn>close pending flag</dfn> which is initially unset.
            </p>
            <p>
              When a <a>connection</a> is initially created it is in <dfn>opened</dfn> state. The connection
              can be <dfn title="database close">closed</dfn> through several means. If the execution context
              where the <a>connection</a> was created is destroyed (for example due to the
              user navigating away from that page), the connection is closed. The connection can also be closed
              explicitly using the <a>steps for closing a database connection</a>. When the connection is closed
              the <a>close pending flag</a> is always set if it hasn't already been.
            </p>
            <p>
              A <a>connection</a> may be closed by a user agent in
              exceptional circumstances, for example due to loss of
              access to the file system or a permission change. If this
              occurs the user agent MUST run the <a>steps for closing a
              database connection</a> with the <a>connection</a> and
              with the <var>forced flag</var> set.
            </p>

            <p>
              A <a>connection</a> has an <dfn>object store set</dfn>, which is initialized to the
              set of <a title="object store">object stores</a> in the associated <a>database</a>
              when the <a>connection</a> is created.

              The contents of the set will remain constant except when
              an <a>upgrade transaction</a> is running.
            </p>

          </section>

        </section>  <!-- Database -->

        <section class="section" id="object-store-concept">
          <h4>Object Store</h4>
          <p>
            An <dfn>object store</dfn> is the primary storage mechanism for storing data in a
            <a>database</a>.
          </p>
          <p>
            Each database has a set of <a title="object store">object stores</a>. The set of <a title="object store">object stores</a> can be changed,
            but only using an <a>upgrade transaction</a>, i.e. in response to an
            <code>upgradeneeded</code> event. When a new database is created it doesn't contain any <a title="object store">object stores</a>.
          </p>
          <p>
            An <a>object store</a> has a <dfn title="object store record list">list of records</dfn> which hold the
            data stored in the object store. Each <dfn>record</dfn> consists of a <a>key</a> and a <a>value</a>.
            The list is sorted according to key in ascending order. There can never be multiple records in a given object
            store with the same key.
          </p>
          <p>
            An <a>object store</a> has a <dfn title="object store name">name</dfn>.
            The name can be any string value, including the empty string.
            At any one time, the name is unique within the <a>database</a> to which it belongs.
            Object store names are always compared in a case-sensitive manner, as opaque sequences of 16-bit code units.
          </p>
          <p>
            An <a>object store</a> optionally has a <dfn title="object store key path">key path</dfn>.
            If the object store has a key path it is said to use <dfn>in-line keys</dfn>. Otherwise it is said to
            use <dfn>out-of-line keys</dfn>.
          </p>
          <p>
            An <a>object store</a> optionally has a <a>key generator</a>.
          </p>
          <p>
            An object store can derive a <a>key</a> for a <a>record</a> from one of three sources:
          </p>
          <ol>
            <li>
              A <a>key generator</a>. A key generator generates a monotonically increasing numbers every time
              a key is needed.
            </li>
            <li>
              Keys can be derived via a <a title="object store key path">key path</a>.
            </li>
            <li>
              Keys can also be explicitly specified when a <a>value</a> is stored in the object store.
            </li>
          </ol>

          <section>
            <h5>Object Store Handle</h5>
            <p>
              Script does not interact with <a title="object store">object stores</a> directly. Instead,
              within a <a>transaction</a>, script has indirect access via an <dfn>object store handle</dfn>.
            </p>
            <p>
              An <a>object store handle</a> has an associated <dfn title="handle object store">object store</dfn> and
              an associated <dfn title="object store handle transaction">transaction</dfn>.
              Multiple handles MAY be associated with the same <a>object store</a> in different <a title="transaction">transactions</a>,
              but there MUST be only one <a>object store handle</a> associated with a particular <a>object store</a> within a <a>transaction</a>.
            </p>
            <p>
              An <a>object store handle</a> has an <dfn>index set</dfn>, which is initialized to the
              set of <a title="index">indexes</a> that reference the associated <a title="handle object store">object store</a>
              when the <a>object store handle</a> is created.

              The contents of the set will remain
              constant except when an <a>upgrade transaction</a> is running.
            </p>
            <p>
              An <a>object store handle</a> has a <dfn title="object store handle name">name</dfn>, which is initialized to the
              <a title="object store name">name</a> of the associated <a title="handle object store">object store</a>
              when the <a>object store handle</a> is created.

              The name will remain
              constant except when an <a>upgrade transaction</a> is running.
            </p>
          </section>

        </section> <!-- Object store -->

        <section id="value-construct" class="section">
          <h4>Values</h4>
          <p>
            Each record is associated with a <dfn>value</dfn>. <a title="conforming user agent">Conforming user agents</a> MUST support
            any ECMAScript [[!ECMA-262]] value supported by the <a>structured clone algorithm</a>
            [[!HTML5]]. This includes simple types such as <code>String</code> primitive values
            and <code>Date</code> objects as well as <code>Object</code> and <code>Array</code>
            instances, <code>File</code> objects, <code>Blob</code> objects, <code>ImageData</code>
            objects, and so on. Record <a title="value">values</a> are stored and retrieved
            by value rather than by reference; later changes to a value have no effect on
            the record stored in the database.
          </p>
        </section> <!-- value-construct -->

        <section id="key-construct" class="section">
          <h4>Keys</h4>
          <p>
            In order to efficiently retrieve <a title="record">records</a> stored in an indexed database,
            each <a>record</a> is organized according to its <dfn>key</dfn>.
          </p>
          <p>
            A <a>key</a> has an associated <dfn title="key type">type</dfn> which is one of:
            <i>number</i>,
            <i>date</i>,
            <i>string</i>,
            <i>binary</i>,
            or
            <i>array</i>.
          </p>
          <aside class="note">&#9752; Support for <i>binary</i> keys is new in this edition. &#9752;</aside>
          <p>
            A <a>key</a> also has an associated <dfn title="key value">value</dfn>, which will
            be either:
            an <a>unrestricted double</a> if type is <i>number</i> or <i>date</i>,
            a <a>DOMString</a> if type is <i>string</i>,
            a list of <a title="octet">octets</a> if type is <i>binary</i>,
            or a list of other <a title="key">keys</a> if type is <i>array</i>.
          </p>
          <p>
            An ECMAScript [[!ECMA-262]] value can be converted to a <a>key</a> by
            following the steps to <a>convert a value to a key</a>.
          </p>

          <aside class="note">
            <p>The following ECMAScript types are valid keys:</p>
            <ul>
              <li><code>Number</code> primitive values, except NaN. This includes Infinity and -Infinity.</li>
              <li><code>Date</code> objects, except where the [<span>[</span>DateValue]] internal slot is NaN</li>
              <li><code>String</code> primitive values.</li>
              <li><code>ArrayBuffer</code> objects (or views on buffers such as <code>Uint8Array</code>).</li>
              <li><code>Array</code> objects, where every item is defined, is itself a valid key, and does not directly or indirectly contain itself.
                This includes empty arrays. Arrays may contain other arrays.</li>
            </ul>
            <p>Attempting to convert other ECMAScript values to a <a>key</a> will fail.</p>
          </aside>

          <p>
            An <dfn>array key</dfn> is a <a>key</a> with <a title="key type">type</a> <i>array</i>.
            The <dfn>subkeys</dfn> of an <a>array key</a> are the members of the <a>array key</a>'s <a title="key value">value</a> list.
          </p>

          <p>
            To <dfn>compare two keys</dfn> <var>a</var> and <var>b</var>, run these steps:
          </p>

          <ol>
            <li>Let <var>ta</var> be the <a title="key type">type</a> of <var>a</var>.</li>
            <li>Let <var>tb</var> be the <a title="key type">type</a> of <var>b</var>.</li>

            <li>If <var>ta</var> is <i>array</i> and <var>tb</var> is
              <i>binary</i>, <i>string</i>, <i>date</i> or <i>number</i>,
              return 1.</li>
            <li>If <var>tb</var> is <i>array</i> and <var>ta</var> is
              <i>binary</i>, <i>string</i>, <i>date</i> or <i>number</i>,
              return -1.</li>

            <li>If <var>ta</var> is <i>binary</i> and <var>tb</var> is
              <i>string</i>, <i>date</i> or <i>number</i>,
              return 1.</li>
            <li>If <var>tb</var> is <i>binary</i> and <var>ta</var> is
              <i>string</i>, <i>date</i> or <i>number</i>,
              return -1.</li>

            <li>If <var>ta</var> is <i>string</i> and <var>tb</var> is
              <i>date</i> or <i>number</i>,
              return 1.</li>
            <li>If <var>tb</var> is <i>string</i> and <var>ta</var> is
              <i>date</i> or <i>number</i>,
              return -1.</li>

            <li>If <var>ta</var> is <i>date</i> and <var>tb</var> is
              <i>number</i>,
              return 1.</li>
            <li>If <var>tb</var> is <i>date</i> and <var>ta</var> is
              <i>number</i>,
              return -1.</li>

            <li>Assert: <var>ta</var> and <var>tb</var> are equal.</li>

            <li>Let <var>va</var> be the <a title="key value">value</a> of <var>a</var>.</li>
            <li>Let <var>vb</var> be the <a title="key value">value</a> of <var>b</var>.</li>

            <li>
              Switch on <var>ta</var>:

              <dl class="switch">
                <dt><i>number</i></dt>
                <dt><i>date</i></dt>
                <dd>
                  <ol>
                    <li>If <var>va</var> is greater than <var>vb</var>, then return 1.</li>
                    <li>If <var>va</var> is less than <var>vb</var>, then return -1.</li>
                    <li>Return 0</li>
                  </ol>
                </dd>

                <dt><i>string</i></dt>
                <dd>
                  <ol>
                    <li>Let <var>length</var> be the lesser of <var>va</var>'s length and <var>vb</var>'s length.</li>
                    <li>Let <var>i</var> be 0.</li>
                    <li>While <var>i</var> is less than <var>length</var>:
                      <ol>
                        <li>Let <var>u</var> be the code unit of <var>va</var> at index <var>i</var></li>
                        <li>Let <var>v</var> be the code unit of <var>vb</var> at index <var>i</var></li>
                        <li>If <var>u</var> is greater than <var>v</var> then return 1</li>
                        <li>If <var>u</var> is less than <var>v</var> then return -1</li>
                        <li>Increase <var>i</var> by 1</li>
                      </ol>
                    </li>
                    <li>If <var>va</var>'s length is greater than <var>vb</var>'s length, then return 1</li>
                    <li>If <var>va</var>'s length is less than <var>vb</var>'s length, then return -1</li>
                    <li>Return 0</li>
                  </ol>
                </dd>

                <dt><i>binary</i></dt>
                <dd>
                  <ol>
                    <li>Let <var>length</var> be the lesser of <var>va</var>'s length and <var>vb</var>'s length.</li>
                    <li>Let <var>i</var> be 0.</li>
                    <li>While <var>i</var> is less than <var>length</var>:
                      <ol>
                        <li>Let <var>u</var> be the <a>octet</a> in <var>va</var> at index <var>i</var></li>
                        <li>Let <var>v</var> be the <a>octet</a> in <var>vb</var> at index <var>i</var></li>
                        <li>If <var>u</var> is greater than <var>v</var> then return 1</li>
                        <li>If <var>u</var> is less than <var>v</var> then return -1</li>
                        <li>Increase <var>i</var> by 1</li>
                      </ol>
                    </li>
                    <li>If <var>va</var>'s length is greater than <var>vb</var>'s length, then return 1</li>
                    <li>If <var>va</var>'s length is less than <var>vb</var>'s length, then return -1</li>
                    <li>Return 0</li>
                  </ol>
                </dd>

                <dt><i>array</i></dt>
                <dd>
                  <ol>
                    <li>Let <var>length</var> be the lesser of <var>va</var>'s length and <var>vb</var>'s length.</li>
                    <li>Let <var>i</var> be 0.</li>
                    <li>While <var>i</var> is less than <var>length</var>:
                      <ol>
                        <li>Let <var>u</var> be the <a>key</a> in <var>va</var> at index <var>i</var></li>
                        <li>Let <var>v</var> be the <a>key</a> in <var>vb</var> at index <var>i</var></li>
                        <li>Let <var>c</var> be the result of recursively running the steps to <a>compare two keys</a>
                          with <var>u</var> and <var>v</var></li>
                        <li>If <var>c</var> is not 0, return <var>c</var></li>
                        <li>Increase <var>i</var> by 1</li>
                      </ol>
                    </li>
                    <li>If <var>va</var>'s length is greater than <var>vb</var>'s length, then return 1</li>
                    <li>If <var>va</var>'s length is less than <var>vb</var>'s length, then return -1</li>
                    <li>Return 0</li>
                  </ol>
                </dd>
              </dl>
            </li>
          </ol>
          <p>
            The <a>key</a> <var>a</var> is <dfn>greater than</dfn> the <a>key</a> <var>b</var> if the result
            of running the steps to <a>compare two keys</a> with <var>a</var> and <var>b</var> is 1.
          </p>
          <p>
            The <a>key</a> <var>a</var> is <dfn>less than</dfn> the <a>key</a> <var>b</var> if the result
            of running the steps to <a>compare two keys</a> with <var>a</var> and <var>b</var> is -1.
          </p>
          <p>
            The <a>key</a> <var>a</var> is <dfn>equal to</dfn> the <a>key</a> <var>b</var> if the result
            of running the steps to <a>compare two keys</a> with <var>a</var> and <var>b</var> is 0.
          </p>

          <aside class="note">
            As a result of the above rules, negative infinity is the lowest possible value for a <a>key</a>.
            <i>Number</i> keys are less than <i>date</i> keys.
            <i>Date</i> keys are less than <i>string</i> keys.
            <i>String</i> keys are less than <i>binary</i> keys.
            <i>Binary</i> keys are less than <i>array</i> keys.
            There is no highest possible <a>key</a> value.
            This is because an array of any candidate highest <a>key</a> followed by another <a>key</a> is even higher.
          </aside>

          <aside class="note">
            Members of <i>binary</i> keys are compared as unsigned octet values (in the range [0, 255])
            rather than signed bytes (in the range [-128, 127]).
          </aside>

        </section> <!-- key-construct -->

        <section id="key-path-construct" class="section">
          <h4>Key Path</h4>
          <p>
            A <dfn>key path</dfn> is a <a>DOMString</a> or <a>sequence&lt;DOMString&gt;</a> that defines how to extract a <a>key</a>
            from a <a>value</a>. A <dfn>valid key path</dfn> is one of:
          </p>
          <ul>
            <li>An empty <a>DOMString</a>.</li>
            <li>An <dfn>identifier</dfn>, which is a <a>DOMString</a> matching
                the <code>IdentifierName</code> production from the ECMAScript Language Specification [[!ECMA-262]].</li>
            <li>A <a>DOMString</a> consisting of two or more <a title="identifier">identifiers</a> separated by
            periods (ASCII character code 46, U+002E FULL STOP).</li>
            <li>A non-empty <a>sequence&lt;DOMString&gt;</a> containing only strings conforming to
            the above requirements.</li>
          </ul>
          <aside class="note">
              Spaces are not allowed within a key path.
          </aside>
          <p>
          	<a>Key path</a> values can only be accessed from properties explicitly copied by the <a>structured clone algorithm</a>,
          	as well as the following type-specific properties:
          </p>
          <table>
            <tr><th>Type</th><th>Properties</th></tr>
            <tr><td><code>Blob</code></td><td><code>size</code>, <code>type</code></td></tr>
            <tr><td><code>File</code></td><td><code>name</code>, <code>lastModified</code>, <code>lastModifiedDate</code></td></tr>
            <tr><td><code>Array</code></td><td><code>length</code></td></tr>
            <tr><td><code>String</code></td><td><code>length</code></td></tr>
          </table>
        </section> <!-- key-path-construct -->

        <section id="index-concept" class="section">
          <h4>Index</h4>
          <p>
            It is sometimes useful to retrieve <a title="record">records</a> in an <a>object store</a> through other means
            than their <a>key</a>. An <dfn>index</dfn> allows looking up <a title="record">records</a> in an <a>object store</a>
            using properties of the <a title="value">values</a> in the <a title="object store">object stores</a> <a title="record">records</a>.
          </p>
          <p>
            An index is a specialized persistent key-value storage and has a <dfn>referenced</dfn> <a>object store</a>.
            The index has a <dfn title="index record list">list of records</dfn> which hold the
            data stored in the index. The records in an index are automatically populated whenever records in the
            <a>referenced</a> object store are inserted, updated or deleted. There can be several <a title="index">indexes</a>
            referencing the same <a>object store</a>, in which changes to the object store cause all such indexes
            to get updated.
          </p>
          <p>
            The values in the index's <a title="record">records</a> are always values of <a title="key">keys</a> in the index's <a>referenced</a>
            object store. The keys are derived from the referenced object store's <a title="value">values</a> using a <dfn title="index key path">key path</dfn>.
            If a given <a>record</a> with key <var>X</var> in the object store referenced by the index has the value <var>A</var>, and
            <a title="extract a key from a value using a key path">evaluating</a> the <a title="index key path">index's key path</a> on <var>A</var> yields the result
            <var>Y</var>, then the index will contain a record with key <var>Y</var> and value <var>X</var>.
          </p>
          <aside class="example">
              For example, if an index's <a>referenced</a> object store contains a record with the key <code>123</code>
              and the value <code>{ first: "Alice", last: "Smith" }</code>, and the <a title="index key path">index's key path</a>
              is "<code>first</code>" then the index would contain a record with the key "<code>Alice</code>" and the value <code>123</code>.
          </aside>
          <p>
            Records in an index are said to have a <dfn>referenced value</dfn>. This is the value of the record in the index's referenced
            object store which has a key equal to the index's record's value. So in the example above,
            the record in the index whose key is <var>Y</var> and value is <var>X</var> has a <a>referenced value</a> of <var>A</var>.
          </p>
          <aside class="example">
              In the preceding example, the record in the index with key "<code>Alice</code>" and value <code>123</code> would have
              a <a>referenced value</a> of <code>{ first: "Alice", last: "Smith" }</code>.
          </aside>
          <aside class="note">
            Each record in an index references one and only one record in the index's <a>referenced</a> object store. However there can be
            multiple records in an index which reference the same record in the object store. And there can also be no records in an index
            which reference a given record in an object store.
          </aside>
          <p>
            The <a title="record">records</a> in an index are always sorted according to the <a title="record">record's</a> key. However unlike object stores,
            a given index can contain multiple records with the same key. Such records are additionally sorted according to
            the <a title="index">index's</a> <a title="record">record's</a> value (meaning the key of the record in the referenced <a>object store</a>).
          </p>
          <p>
            An <a>index</a> has a <dfn title="index name">name</dfn>.
            The name can be any string value, including the empty string.
            At any one time, the name is unique within index's <a>referenced</a> <a>object store</a>.
            Index names are always compared in a case-sensitive manner, as opaque sequences of 16-bit code units.
          </p>
          <p>
            An <a>index</a> has a <dfn>unique flag</dfn>. When this flag is set, the index enforces that no two <a title="record">records</a>
            in the index has the same key. If a <a>record</a> in the index's referenced object store is attempted to be inserted or
            modified such that evaluating the index's key path on the records new value yields a result which already exists in the
            index, then the attempted modification to the object store fails.
          </p>
          <p>
            An <a>index</a> has a <dfn>multiEntry flag</dfn>. This flag affects how the index behaves when the result of evaluating
            the index's <a title="index key path">key path</a> yields an <a>array key</a>. If the <a>multiEntry flag</a> is unset, then
            a single <a>record</a> whose <a>key</a> is an <a>array key</a> is added to the index. If the <a>multiEntry flag</a> is
            true, then the one <a>record</a> is added to the index for each of the <a>subkeys</a>.
          </p>

          <section>
            <h5>Index Handle</h5>
            <p>
              Script does not interact with <a title="index">indexes</a> directly. Instead,
              within a <a>transaction</a>, script has indirect access via an <dfn>index handle</dfn>.
            </p>
            <p>
              An <a>index handle</a> has an associated <dfn title="handle index">index</dfn> and
              an associated <dfn title="index handle object store">object store handle</dfn>.
              The <dfn title="index handle transaction">transaction</dfn> of an <a>index handle</a> is the
              <a title="object store handle transaction">transaction</a> of its associated <a>object store handle</a>.
              Multiple handles MAY be associated with the same <a>index</a> in different <a title="transaction">transactions</a>,
              but there MUST be only one <a>index handle</a> associated with a particular <a>index</a> within a <a>transaction</a>.
            </p>
            <p>
              An <a>index handle</a> has a <dfn title="index handle name">name</dfn>, which is initialized to the
              <a title="index name">name</a> of the associated <a title="handle index">index</a>
              when the <a>index handle</a> is created.

              The name will remain
              constant except when an <a>upgrade transaction</a> is running.
            </p>
          </section>

        </section> <!-- index-construct -->

        <section id="transaction-concept" class="section">
          <h4>Transactions</h4>
          <p>
            A <dfn>transaction</dfn> is used to interact with the data in a <a>database</a>.
            Whenever data is read or written to the database it is done by using a <a>transaction</a>.
          </p>
          <p>
            <a title="transaction">Transactions</a> offer some protection from
            application and system failures. A <a>transaction</a> may be used to
            store multiple data records or to conditionally modify certain data
            records. A <a>transaction</a> represents an atomic and durable set
            of data access and data mutation operations.
          </p>
          <p>
            All transactions are created through a <a>connection</a>, which is the transaction's
            <dfn title="transaction connection">connection</dfn>.
          </p>

          <p>
            A <a>transaction</a> has a <dfn>scope</dfn> that
            determines the <a title="object store">object stores</a> with which the transaction may interact.
            A transaction's scope remains fixed for the lifetime of that transaction.
          </p>

          <p>
            A <a>transaction</a> has a <dfn>mode</dfn> that determines which types of interactions can be performed
            upon that transaction. The <a>mode</a> is set when the transaction is created and remains
            fixed for the life of the transaction. A <a>transaction</a>'s <a>mode</a> is one of the following:
          </p>
          <dl>
            <dt>"<code>readonly</code>"</dt>
            <dd>
                The transaction is only allowed
                to read data. No modifications can be done by this type of transaction. This has the advantage
                that several <a title="read-only transaction">read-only transactions</a> can run at the same time even if their <a title="scope">scopes</a>
                are overlapping, i.e. if they are using the same object stores. This type of transaction can
                be created any time once a database has been opened.
            </dd>

            <dt>"<code>readwrite</code>"</dt>
            <dd>
                The transaction is allowed to read, modify and
                delete data from existing object stores. However object stores and indexes can't be added or removed.
                Multiple "<code>readwrite</code>" transactions can't run at the same time if their <a title="scope">scopes</a> are overlapping
                since that would mean that they can modify each other's data in the middle of the transaction.
                This type of transaction can be created any time once a database has been opened.
            </dd>

            <dt>"<code>versionchange</code>"</dt>
            <dd>
                The transaction is allowed to read, modify and
                delete data from existing object stores, and can also
                create and remove object stores and indexes. It is the only type of
                transaction that can do so. This type of transaction can't be manually created, but instead is created
                automatically when an <a><code>upgradeneeded</code></a> event is fired.
            </dd>
          </dl>

          <p>
            A <a>transaction</a> has an <dfn>active flag</dfn>, which determines if new <a title="request">requests</a> can be made
            against the transaction.
            A transaction is said to be <dfn>active</dfn> if its <a>active flag</a> is set.
          </p>
          <p>
            A <a>transaction</a> has a <dfn>request list</dfn> of
            <a title="request">requests</a> which have been made against the transaction.
          </p>
          <p>
            A <a>transaction</a> has a <dfn title="transaction error">error</dfn> which is set if the
            <a>transaction</a> is <a title="transaction abort">aborted</a>.
          </p>

          <p>
            <a title="transaction">Transactions</a> are expected to be short lived. This is encouraged
            by the <a title="transaction commit">automatic committing</a> functionality described below.
          </p>
          <aside class="note">
            Authors can still cause
            transactions to run for a long time; however, this usage pattern
            is not generally recommended as it can lead to a bad user experience.
          </aside>

          <p>
            The <dfn title="transaction lifetime">lifetime</dfn> of a <a>transaction</a> is as follows:
          </p>
          <ol>
            <li>
              A transaction is <dfn title="transaction create">created</dfn> with a <a>scope</a> and a <a>mode</a>.
              When a transaction is created its <a>active flag</a> is initially set.
            </li>
            <li>
              The implementation MUST allow <a title="request">requests</a> to be <a title="place request">placed</a> against the transaction
              whenever the <a>active flag</a> is set. This is the case even if the transaction has not yet been
              <a title="transaction start">started</a>. Until the transaction is <a title="transaction start">started</a>
              the implementation MUST NOT execute these requests; however, the implementation MUST keep track of the
              <a title="request">requests</a> and their order. Requests may be placed against a transaction only while that transaction
              is <a>active</a>. If an attempt is made to place a request against a transaction when that transaction is not
              <a>active</a>, the implementation MUST reject the attempt by
              throwing a <a>TransactionInactiveError</a> exception.
            </li>
            <li>
              Once an implementation is able to enforce the constraints defined for the transaction <a>scope</a> and <a>mode</a>, defined below,
              the implementation MUST <a>queue a task</a> to <dfn title="transaction start">start</dfn> the transaction asynchronously.
            </li>
            <li>
              Once the transaction has been <a title="transaction start">started</a> the implementation can
              start executing the <a title="request">requests</a> placed against the transaction. Unless otherwise defined, requests
              MUST be executed in the order in which they were made against the transaction. Likewise, their results MUST
              be returned in the order the requests were placed against a specific transaction.
              There is no guarantee about the order that results from requests in different transactions are returned.
              Similarly, the transaction <a title="mode">modes</a> ensure that two requests placed against different transactions
              can execute in any order without affecting what resulting data is stored in the database.
            </li>
            <li>
              A transaction can be <dfn title="transaction abort">aborted</dfn> at any time before it is <a title="transaction finish">finished</a>,
              even if the transaction isn't currently <a>active</a> or hasn't yet <a title="transaction start">started</a>.
              When a transaction is aborted the implementation MUST undo (roll back) any changes
              that were made to the <a>database</a> during that transaction. This includes both changes to the contents of
              <a title="object store">object stores</a> as well as additions and removals of <a title="object store">object stores</a> and <a title="index">indexes</a>.
            </li>
            <li>
              A transaction can fail for reasons not tied to a particular <a>request</a>. For example due to IO errors
              when committing the transaction, or due to running into a quota limit where the implementation can't tie
              exceeding the quota to a partcular request. In this case the implementation MUST run the
              <a>steps for aborting a transaction</a> using the transaction as <var>transaction</var> and the appropriate
              error type as <var>error</var>. For example if quota was exceeded then <a>QuotaExceededError</a> should
              be used as <var>error</var>, and if an IO error happened, <a>UnknownError</a> should be used as
              <var>error</var>.
            </li>
            <li>
              When a transaction can no longer become <a>active</a>, the implementation MUST attempt to
              <dfn title="transaction commit">commit</dfn> it, as long as the transaction has not been <a title="transaction abort">aborted</a>.
              This usually happens after all requests placed against the
              transaction have been executed and their returned results handled, and no new requests have been placed
              against the transaction. When a transaction is committed, the implementation MUST atomically write
              any changes to the <a>database</a> made by requests placed against the transaction. That is, either all
              of the changes MUST be written, or if an error occurs, such as a disk write error, the implementation
              MUST NOT write any of the changes to the database. If such an error occurs, the implementation MUST
              <a title="transaction abort">abort</a> the transaction by following the <a>steps for aborting a transaction</a>, otherwise it
              MUST <a title="transaction commit">commit</a> the transaction by following the <a>steps for committing a transaction</a>.
            </li>
            <li>
              When a transaction is <a title="transaction commit">committed</a> or <a title="transaction abort">aborted</a>, it is said to be
              <dfn title="transaction finish">finished</dfn>. If a transaction can't be finished, for example
              due to the implementation crashing or the user taking some explicit action to cancel it, the
              implementation MUST <a title="transaction abort">abort</a> the transaction.
            </li>
          </ol>

          <p>
            A <dfn>read-only transaction</dfn> is a <a>transaction</a> with <a>mode</a> "<code>readonly</code>".
          </p>
          <p>
            A <dfn>read/write transaction</dfn> is a <a>transaction</a> with <a>mode</a> "<code>readwrite</code>".
          </p>

          <p>
            The following constraints define when a <a>transaction</a> can be <a title="transaction start">started</a>:
          </p>

          <ul>
            <li>
              Any number of <a title="read-only transaction">read-only transactions</a> are allowed to run concurrently,
              even if the transaction's <a>scope</a> overlap and include the same <a title="object store">object stores</a>.
              As long as a <a>read-only transaction</a> is running, the data that the implementation returns
              through <a title="request">requests</a> created with that transaction MUST remain
              constant. That is, two requests to read the same piece of data MUST yield the same result
              both for the case when data is found and the result is that data, and for the case when data
              is not found and a lack of data is indicated.
              <aside class="note">
                There are a number of ways that an implementation can ensure this. The implementation could prevent any
                <a>read/write transaction</a>, whose scope overlaps the scope of the <a>read-only transaction</a>, from
                starting until the <a>read-only transaction</a> finishes. Or the implementation could allow the
                <a>read-only transaction</a> to see a snapshot of the contents of the <a title="object store">object stores</a> which is taken when
                the <a>read-only transaction</a> started.
              </aside>
            </li>

            <li>
              Similarly, implementations MUST ensure that a <a>read/write transaction</a> is only affected by
              changes to <a title="object store">object stores</a> that are made using the transaction itself. For example, the
              implementation MUST ensure that another transaction does not modify the contents of
              <a title="object store">object stores</a> in the <a>read/write transaction</a>'s <a>scope</a>. The implementation
              MUST also ensure that if the <a>read/write transaction</a> completes successfully, the
              changes written to <a title="object store">object stores</a> using the transaction can be committed to the
              <a>database</a> without merge conflicts. An implementation MUST NOT abort a transaction
              due to merge conflicts.
            </li>

            <li>
              If multiple <a title="read/write transaction">read/write transactions</a> are attempting to access the same object store (i.e.
              if they have overlapping <a>scope</a>), the transaction that was <a title="transaction create">
              created</a> first MUST be the transaction which gets access to the object store first. Due to
              the requirements in the previous paragraph, this also means that it is the only transaction
              which has access to the object store until the transaction is <a title="transaction finish">finished</a>.
            </li>

            <li>
              Any transaction
              <a title="transaction create">created</a> after a
              <a>read/write transaction</a> MUST see the changes
              written by the <a>read/write transaction</a>. So if
              a
              <a>read/write transaction</a>, A, is created, and
              later another transaction B, is created, and the two
              transactions have overlapping
              <a title="scope">scopes</a>, then B MUST see any changes
              made to any <a title="object store">object stores</a> that
              are part of that overlapping <a>scope</a>. Due to the
              requirements in the previous paragraph, this also means
              that the B transaction does not have access to any
              <a title="object store">object stores</a> in that
              overlapping <a>scope</a> until the A transaction
              is <a title="transaction finish">finished</a>.

              <aside class="note">
                Generally speaking, the above requirements mean that any
                transaction which has an overlapping scope with a
                <a>read/write transaction</a> and which was created
                after that
                <a>read/write transaction</a>, can't run in
                parallel with that
                <a>read/write transaction</a>.
              </aside>
            </li>

            <li>
              User agents MUST ensure a reasonable level of fairness across transactions to prevent
              starvation. For example, if multiple <a title="read-only transaction">read-only transactions</a> are started one after another
              the implementation MUST NOT indefinitely prevent a pending <a>read/write transaction</a>
              from <a title="transaction start">starting</a>.
            </li>
          </ul>

          <section>
            <h5>Upgrade Transactions</h5>
            <p>
              An <dfn>upgrade transaction</dfn> is a <a>transaction</a> with <a>mode</a> "<code>versionchange</code>".
            </p>
            <p>
              An <a>upgrade transaction</a> is automatically created when running
              <a>steps for running an upgrade transaction</a> after a <a>connection</a> is opened
              to a <a>database</a> giving a greater <a>version</a> than the current <a>version</a>.
              This <a>transaction</a> will be active inside the <a><code>upgradeneeded</code></a> event handler,
              allowing the creation of new <a title="object store">object stores</a> and <a title="index">indexes</a>.
            </p>
            <p>
              An <a>upgrade transaction</a> is never run concurrently with other transactions.
              When a database is opened with a <a>version</a> number higher than the current <a>version</a>, a new
              <a>upgrade transaction</a> is automatically created and made available through the <a>open request</a>
              when the <a><code>upgradeneeded</code></a> event is fired.
              The <a><code>upgradeneeded</code></a> event isn't fired, and thus the
              <a>upgrade transaction</a> isn't started, until all other <a title="connection">connections</a> to the same
              <a>database</a> are closed. This ensures that all other transactions are <a title="transaction finish">finished</a>.
            </p>
            <p>
              As long as an <a>upgrade transaction</a>
              is running, attempts to open more <a title="connection">connections</a> to the same <a>database</a> are delayed,
              and any attempts to use the same <a>connection</a> to start additional transactions will result in
              an exception being thrown. Thus <a title="upgrade transaction">upgrade transactions</a> not only ensure that
              no other transactions are running concurrently, but also ensure that no other transactions are queued
              against the same <a>database</a> as long as the transaction is running.
            </p>
          </section>
        </section> <!-- Transaction -->

        <section class="section" id="request-concept">
          <h4>Requests</h4>
          <p>
            Each asynchronous operation on a <a>database</a> is done using a <dfn>request</dfn>.
            Every request represents one operation.
          </p>
          <p>
            A <a>request</a> has a <dfn title="request done">done flag</dfn> which is
            initially unset.
          </p>
          <p>
            A <a>request</a> has a <dfn title="request source">source</dfn> object.
          </p>
          <p>
            A <a>request</a> has a <dfn title="request result">result</dfn> and an <dfn title="request error">error</dfn>,
            neither of which are accessible until the <a title="request done">done flag</a> is set.
          </p>
          <p>
            A <a>request</a> has a <dfn title="request transaction">transaction</dfn> which is initially null.
            This will be set when a request is <dfn title="place request">placed</dfn> against a <a>transaction</a> using
            the <a>steps for asynchronously executing a request</a>.
          </p>
          <p>
            When a request is made, a new <a>request</a> is returned with its
            <a title="request done">done flag</a> unset.
            If a request completes successfully, the
            <a title="request done">done flag</a> is set, the
            <a title="request result">result</a>
            is set to the result of the request, and an event with type <code>success</code> is fired
            at the <a>request</a>.
          </p>
          <p>
            If an error occurs while performing the operation, the
            <a title="request done">done flag</a> is set, the
            <a title="request error">error</a> is set to the error,
            and an event with type <code>error</code> is fired at the request.
          </p>

          <p>
            An <dfn>open request</dfn> is a special type of <a>request</a> used when opening a <a>connection</a>
            or deleting a <a>database</a>. In addition to <code>success</code> and <code>error</code> events,
            <code>blocked</code> and <code>upgradeneeded</code> may be fired at an <a>open request</a> to indicate progress.
          </p>
          <p>
            The <a title="request source">source</a> of an <a>open request</a> is always null.
          </p>
          <p>
            The <a title="request transaction">transaction</a> of an <a>open request</a> is null unless an <a><code>upgradeneeded</code></a>
            event has been fired.
          </p>

          <aside class="note">
            Requests are not typically re-used, but there are exceptions. When a <a>cursor</a> is iterated,
            the success of the iteration is reported on the same <a>request</a> object used to open the cursor.
            And when an <a>upgrade transaction</a> is necessary, the same <a>open request</a> is used for
            both the <a><code>upgradeneeded</code></a> event and final result of the open operation itself.
            In both cases, the request's <a title="request done">done flag</a> will be unset then set again, and the
            <a title="request result">result</a> may change.
          </aside>

        </section> <!-- Requests -->

        <section class="section" id="range-concept">
          <h4>Key Range</h4>
          <p>
            Records can be retrieved from <a title="object store">object stores</a> and <a title="index">indexes</a>
            using either <a title="key">keys</a> or <a title="key range">key ranges</a>. A
            <dfn>key range</dfn> is a continuous interval over some data type
            used for keys.
          </p>
          <p>
            A <a>key range</a> has an associated <dfn>lower bound</dfn> (null or a <a>key</a>).
          </p>
          <p>
            A <a>key range</a> has an associated <dfn>upper bound</dfn> (null or a <a>key</a>).
          </p>
          <p>
            A <a>key range</a> has an associated <dfn>lower open flag</dfn>. Unless otherwise stated it is unset.
          </p>
          <p>
            A <a>key range</a> has an associated <dfn>upper open flag</dfn>. Unless otherwise stated it is unset.
          </p>

          <p>
            A <a>key range</a> MAY have a <a>lower bound</a> <a>equal to</a> its <a>upper bound</a>.
            A <a>key range</a> MUST NOT have a <a>lower bound</a> <a>greater than</a> its <a>upper bound</a>.
          </p>

          <p>
            A <a>key range</a> <dfn>containing only</dfn> <var>key</var> has both
            <a>lower bound</a> and <a>upper bound</a> equal to <var>key</var>.
          </p>

          <p>
            A <var>key</var> is <dfn>in a key range</dfn> if both of the following conditions are
            fulfilled:
          </p>
          <ul>
            <li>
              The <a>lower bound</a> is null,
              or it is <a>less than</a> <var>key</var>,
              or it is both <a>equal to</a> <var>key</var> and the <a>lower open flag</a> is unset.
            </li>
            <li>
              The <a>upper bound</a> is null,
              or it is <a>greater than</a> <var>key</var>,
              or it is both <a>equal to</a> <var>key</var> and the <a>upper open flag</a> is unset.
            </li>
          </ul>

          <aside class="note">
            <ul>
              <li>
                If the <a>lower open flag</a> of a <a>key range</a> is unset, the <a>lower bound</a> <a>key</a> of the
                <a>key range</a> is included in the range itself.
              </li>
              <li>
                If the <a>lower open flag</a> of a <a>key range</a> is set, the <a>lower bound</a> <a>key</a> of the
                <a>key range</a> is excluded from the range itself.
              </li>
              <li>
                If the <a>upper open flag</a> of a <a>key range</a> is unset, the <a>upper bound</a> <a>key</a> of the
                <a>key range</a> is included in the range itself.
              </li>
              <li>
                If the <a>upper open flag</a> of a <a>key range</a> is set, the <a>upper bound</a> <a>key</a> of the
                <a>key range</a> is excluded from the range itself.
              </li>
            </ul>
          </aside>

          <p>
            An <dfn>unbounded key range</dfn> is a <a>key range</a> that has both
            <a>lower bound</a> and <a>upper bound</a> equal to null. All
            <a title="key">keys</a> are <a title="in a key range">in</a> an
            <a>unbounded key range</a>.
          </p>

          <p>
            The steps to <dfn>convert a value to a key range</dfn> with <var>value</var>
            and optional <var>null allowed flag</var> are as follows:
          </p>
          <ol>
            <li>
              If <var>value</var> is a <a>key range</a>, return <var>value</var>.
            </li>
            <li>
              If <var>value</var> is undefined or is null,
              then <a>throw</a> a <a>DataError</a> exception if <var>null disallowed flag</var> is set,
              or return an <a>unbounded key range</a> otherwise.
            </li>
            <li>
              Let <var>key</var> be the result of running the steps to <a>convert a value to a key</a> with <var>value</var>.
              If this throws an exception, <a title="throw">rethrow</a> it.
            </li>
            <li>
              If <var>key</var> is invalid, <a>throw</a> a <a>DataError</a> exception.
            </li>
            <li>
              Return a <a>key range</a> <a>containing only</a> <var>key</var>.
            </li>
          </ol>
        </section> <!-- key-range-construct -->

        <section id="cursor-concept" class="section">
          <h4>Cursor</h4>
          <p>
            A <dfn>cursor</dfn> is used to iterate over a range of records in an <a>index</a> or an <a>object store</a>
            in a specific direction.
          </p>

          <p>
            A <a>cursor</a> has a <dfn title="cursor transaction">transaction</dfn>, the <a>transaction</a> that was
            <a title"transaction active">active</a> when the cursor was created.
          </p>
          <p>
            A <a>cursor</a> has a <dfn>range</dfn> of records in either an <a>index</a> or an <a>object store</a>.
          </p>

          <p>
            A <a>cursor</a> has a <dfn title="cursor source">source</dfn> that indicates which
            <a>index</a> or an <a>object store</a> is associated with the records over which the <a>cursor</a> is iterating.
          </p>

          <p>
            A <a>cursor</a> has a <dfn>direction</dfn> that determines whether it moves in
            monotonically increasing or decreasing order of the <a>record</a> keys when iterated,
            and if it skips duplicated values when iterating indexes. The direction of a cursor also determines
            if the cursor initial position is at the start of its <a title="cursor source">source</a> or at its end.
            A cursor's <a>direction</a> is one of the following:
          </p>

          <dl>
            <dt>"<code>next</code>"</dt>
            <dd>This direction causes the cursor to be opened at the start of the
            <a title="cursor source">source</a>. When iterated, the <a>cursor</a> should yield all records, including
            duplicates, in monotonically increasing order of keys.</dd>

            <dt>"<code>nextunique</code>"</dt>
            <dd>This direction causes the cursor to be opened at the start of the
            <a title="cursor source">source</a>. When iterated, the <a>cursor</a> should not yield records with
            the same key, but otherwise yield all records, in monotonically increasing order of keys. For every key
            with duplicate values, only the first record is yielded. When the <a title="cursor source">source</a> is
            an <a>object store</a> or an <a>index</a> with the <a>unique flag</a> set, this direction has exactly the same behavior as "<code>next</code>".</dd>

            <dt>"<code>prev</code>"</dt>
            <dd>This direction causes the cursor to be opened at the end of the
            <a title="cursor source">source</a>. When iterated, the <a>cursor</a> should yield all records, including
            duplicates, in monotonically decreasing order of keys.</dd>

            <dt>"<code>prevunique</code>"</dt>
            <dd>This direction causes the cursor to be opened at the end of the
            <a title="cursor source">source</a>. When iterated, the <a>cursor</a> should not yield records with
            the same key, but otherwise yield all records, in monotonically decreasing order of keys. For every key
            with duplicate values, only the first record is yielded. When the <a title="cursor source">source</a> is
            an <a>object store</a> or an <a>index</a> with the <a>unique flag</a> set, this direction has exactly the same behavior as "<code>prev</code>".</dd>
          </dl>

          <p>
            A <a>cursor</a> has a <dfn>position</dfn> within its range.
            It is possible for the list of records which the cursor is iterating over to
            change before the full <a>range</a> of the cursor has been iterated. In order to
            handle this, cursors maintain their <a>position</a> not as an index, but rather
            as a <a>key</a> of the previously returned record. For a forward iterating cursor,
            the next time the cursor is asked to iterate to the next record it returns the
            record with the lowest <a>key</a> <a>greater than</a> the one previously returned. For
            a backwards iterating cursor, the situation is opposite and it returns the record
            with the highest <a>key</a> <a>less than</a> the one previously returned.
          </p>
          <p>
            For cursors iterating indexes the situation is a little bit more complicated since
            multiple records can have the same key and are therefore also sorted by <a>value</a>.
            When iterating indexes the <a>cursor</a> also has an <dfn>object store position</dfn>, which indicates
            the <a>value</a> of the previously found <a>record</a> in the index. Both
            <a>position</a> and the <a>object store position</a> are used when finding the next appropriate record.
          </p>

          <p>
            A <a>cursor</a> has a <dfn title="cursor key">key</dfn> and a <dfn title="cursor value">value</dfn>
            which represent the <a>key</a> and the <a>value</a> of the last iterated <a>record</a>.
          </p>

          <p>
            A <a>cursor</a> has a <dfn>got value flag</dfn>. When this flag unset, the cursor is either
            in the process of loading the next value or it has reached the end of its <a>range</a>. When it
            is set, it indicates that the cursor is currently holding a value and that it is ready to iterate
            to the next one.
          </p>

          <p>
            If the <a title="cursor source">source</a> of a cursor is an <a>object store</a>, the <dfn>effective object store</dfn>
            of the cursor is that object store and the <dfn>effective key</dfn> of the cursor is the cursor's <a>position</a>.
            If the <a title="cursor source">source</a> of a cursor is an <a>index</a>, the <a>effective object store</a>
            of the cursor is that index's <a>referenced</a> object store and the <a>effective key</a> is the cursor's
            <a>object store position</a>.
          </p>

          <p>
            A <a>cursor</a> also has a <dfn>key only flag</dfn>, that indicates whether the cursor's
            <a title="cursor value">value</a> is exposed via the API. Unless stated otherwise it is unset.
          </p>
        </section> <!-- cursor-construct -->

        <section id="key-generator-concept" class="section">
          <h4>Key Generators</h4>
          <p>
            When a <a>object store</a> is created it can be specified to use a <dfn>key generator</dfn>.
            A <a>key generator</a> keeps an internal <dfn>current number</dfn>. The <a>current number</a>
            is always a positive integer. Whenever the key generator is used to generate a new <a>key</a>, the
            generator's <a>current number</a> is returned and <strong>then</strong> incremented to prepare
            for the next time a new <a>key</a> is needed. Implementations MUST use the following rules
            for generating numbers when a <a>key generator</a> is used.
          </p>
          <ul>
            <li>
              Every object store that uses key generators use a separate generator. I.e. interacting with one
              object store never affects the key generator of any other object store.
            </li>
            <li>
              The <a>current number</a> of a <a>key generator</a> is always set to 1 when the
              <a>object store</a> for that key generator is first created.
            </li>
            <li>
              When a key generator is used to generate a new <a>key</a> for a <a>object store</a>, the
              key generator's <a>current number</a> is used as the new key value and then the
              key generator's <a>current number</a> is increased by 1.
            </li>
            <li>
              <p>
                When a <a>record</a> is stored and a <a>key</a> is specified in the call to store the record,
                if <a title="key type">type</a> of the key is <i>number</i> and the
                <a title="key value">value</a> is greater than or equal to the key generator's
                <a>current number</a>, then the key generator's <a>current number</a> is set to the smallest integer
                number <a>greater than</a> the explicit key.
                A key can be specified both for object stores which use <a>in-line keys</a>, by setting the
                property on the stored value which the <a title="object store key path">object store's key path</a>
                points to, and for object stores which use <a>out-of-line keys</a>, by passing a key argument
                to the call to store the <a>record</a>.
              </p>
              <aside class="note">
                Only specified keys of <a title="key type">type</a> <i>number</i>
                may affect the <a>current number</a> of the key generator. Keys of <a title="key type">type</a>
                <i>date</i>, <i>array</i> (regardless of the other keys they contain), <i>binary</i>, or
                <i>string</i> (regardless of whether they could be parsed as numbers) have
                no effect on the <a>current number</a> of the key generator.
                Keys of <a title="key type">type</a> <i>number</i> with <a title="key value">value</a>
                less than 1
                do not affect the <a>current number</a> since they are always lower than the <a>current
                number</a>.
              </aside>
            </li>
            <li>
              Modifying a key generator's <a>current number</a> is considered part of a database operation.
              This means that if the operation fails and the operation is reverted, the <a>current number</a>
              is reverted to the value it had before the operation started. This applies both to modifications
              that happen due to the <a>current number</a> getting increased by 1 when the key
              generator is used, and to modifications that happen due to a <a>record</a> being stored with a
              key value specified in the call to store the <a>record</a>.
            </li>
            <li>
              Likewise, if a <a>transaction</a> is aborted, the <a>current number</a> of the key generator
              for each <a>object store</a> in the transaction's <a>scope</a> is reverted to the value it
              had before the <a>transaction</a> was started.
            </li>
            <li>
              When the <a>current number</a> of a key generator reaches above the value 2<sup>53</sup>
              (9007199254740992) any attempts to use the key generator to generate a new
              <a>key</a> will result in a <a>ConstraintError</a>.
              It is still possible to insert <a title="record">records</a> into the
              object store by specifying an explicit key, however the only way to use a key generator
              again for the object store is to delete the object store and create a new one.
              <aside class="note">
                As long as key generators are used in a normal fashion this will not be a problem.
                If you generate a new key 1000 times per second day and night, you won't run into this limit
                for over 285000 years.
              </aside>
            </li>
            <li>
              The <a>current number</a> for a key generator never decreases, other than as a result of
              database operations being reverted. Deleting a <a>record</a> from an <a>object store</a>
              never affects the object store's key generator. Even clearing all records from an
              object store, for example using the
              <a href="#widl-IDBObjectStore-clear-IDBRequest"><code>clear()</code></a> method, does
              not affect the <a>current number</a> of the object store's key generator.
            </li>
          </ul>
          <p>
            A practical result of this is that the first key generated for an object store is always 1
            (unless a higher numeric key is inserted first) and the key generated for an object store is always a
            positive integer higher than the highest numeric key in the store. The same key is never generated
            twice for the same object store unless a transaction is rolled back.
          </p>
          <aside class="example">
            <p>Each object store gets its own key generator:</p>
            <pre class="example highlight">
store1 = db.createObjectStore("store1", { autoIncrement: true });
store1.put("a"); // Will get key 1
store2 = db.createObjectStore("store2", { autoIncrement: true });
store2.put("a"); // Will get key 1
store1.put("b"); // Will get key 2
store2.put("b"); // Will get key 2
            </pre>

            <p>If an insertion fails due to constraint violations or IO error, the
            key generator is not updated.</p>
            <pre class="example highlight">
transaction.onerror = function(e) { e.preventDefault() };
store = db.createObjectStore("store1", { autoIncrement: true });
index = store.createIndex("index1", "ix", { unique: true });
store.put({ ix: "a"}); // Will get key 1
store.put({ ix: "a"}); // Will fail
store.put({ ix: "b"}); // Will get key 2
            </pre>

            <p>Removing items from an objectStore never affects the key generator.
            Including when .clear() is called.</p>
            <pre class="example highlight">
store = db.createObjectStore("store1", { autoIncrement: true });
store.put("a"); // Will get key 1
store.delete(1);
store.put("b"); // Will get key 2
store.clear();
store.put("c"); // Will get key 3
store.delete(IDBKeyRange.lowerBound(0));
store.put("d"); // Will get key 4
            </pre>

            <p>Inserting an item with an explicit key affects the key generator if,
            and only if, the key is numeric and higher than the last generated
            key.</p>
            <pre class="example highlight">
store = db.createObjectStore("store1", { autoIncrement: true });
store.put("a"); // Will get key 1
store.put("b", 3); // Will use key 3
store.put("c"); // Will get key 4
store.put("d", -10); // Will use key -10
store.put("e"); // Will get key 5
store.put("f", 6.00001); // Will use key 6.0001
store.put("g"); // Will get key 7
store.put("f", 8.9999); // Will use key 8.9999
store.put("g"); // Will get key 9
store.put("h", "foo"); // Will use key "foo"
store.put("i"); // Will get key 10
store.put("j", [1000]); // Will use key [1000]
store.put("k"); // Will get key 11
// All of these would behave the same if the objectStore used a
keyPath and the explicit key was passed inline in the object
            </pre>

            <p>Aborting a transaction rolls back any increases to the key generator
            which happened during the transaction. This is to make all rollbacks
            consistent since rollbacks that happen due to crash never has a chance
            to commit the increased key generator value.</p>
            <pre class="example highlight">
db.createObjectStore("store", { autoIncrement: true });
trans1 = db.transaction(["store"], "readwrite");
store_t1 = trans1.objectStore("store");
store_t1.put("a"); // Will get key 1
store_t1.put("b"); // Will get key 2
trans1.abort();
trans2 = db.transaction(["store"], "readwrite");
store_t2 = trans2.objectStore("store");
store_t2.put("c"); // Will get key 1
store_t2.put("d"); // Will get key 2
            </pre>
          </aside>
          <aside class="example">
            <p>
              The following examples illustrate the different behaviors when trying to use in-line <a title="key">keys</a> and <a title="key generator">key generators</a>
              to save an object to an <a>object store</a>.
            </p>
            <p>If the following conditions are true:</p>
              <ul>
                <li>The <a>object store</a> has a <a>key generator</a>.</li>
                <li>There is no in-line value for the <a>key path</a> property.</li>
              </ul>
              <p>
                Then the value provided by the <a>key generator</a> is used to populate the key value.
                In the example below the <a>key path</a> for the object store is "<code>foo.bar</code>".
                The actual object has no value for the <code>bar</code> property, <code>{ foo: {} }</code>.
                When the object is saved in the <a>object store</a> the <code>bar</code> property is assigned a value of 1
                because that is the next <a>key</a> generated by the <a>key generator</a>.
              </p>
            <pre class="example highlight">
var store = db.createObjectStore("store", { keyPath: "foo.bar", autoIncrement: true });
store.put({ foo: {} }).onsuccess = function(e) {
  var key = e.target.result;
  console.assert(key === 1);
};
            </pre>
            <p>If the following conditions are true:</p>
              <ul>
                <li>The <a>object store</a> has a <a>key generator</a>.</li>
                <li>There is a value for the <a>key path</a> property.</li>
              </ul>
            <p>
              Then the value associated with the <a>key path</a> property is used.
              The auto-generated <a>key</a> is not used.
              In the example below the <a>key path</a> for the <a>object store</a> is "<code>foo.bar</code>".
              The actual object has a value of 10 for the <code>bar</code> property, <code>{ foo: { bar: 10} }</code>.
              When the object is saved in the <a>object store</a> the <code>bar</code> property keeps its value of 10, because that is the key value.
            </p>
            <pre class="example highlight">
var store = db.createObjectStore("store", { keyPath: "foo.bar", autoIncrement: true });
store.put({ foo: { bar: 10 } }).onsuccess = function(e) {
  var key = e.target.result;
  console.assert(key === 10);
};
            </pre>
            <p>
              The following example illustrates the scenario when the specified in-line <a>key</a> is defined through a <a>key path</a> but there is no property matching it.
              The value provided by the <a>key generator</a> is then used to populate the key value and the system is responsible
              for creating as many properties as it requires to suffice the property dependencies on the hierarchy chain.
              In the example below the <a>key path</a> for the <a>object store</a> is "<code>foo.bar.baz</code>".
              The actual object has no value for the <code>foo</code> property, <code>{ zip: {} }</code>.
              When the object is saved in the <a>object store</a> the <code>foo</code>, <code>bar</code>, and <code>baz</code> properties
              are created each as a child of the other until a value for <code>foo.bar.baz</code> can be assigned.
              The value for <code>foo.bar.baz</code> is the next key generated by the object store.
            </p>
            <pre class="example highlight">
var store = db.createObjectStore("store", { keyPath: "foo.bar.baz", autoIncrement: true });
store.put({ zip: {} }).onsuccess = function(e) {
  var key = e.target.result;
  console.assert(key === 1);
  store.get(key).onsuccess = function(e) {
    var value = e.target.result;
    // value will be: { zip: {}, foo: { bar: { baz: 1 } } }
    console.assert(value.foo.bar.baz === 1);
  };
};
            </pre>
            <p>
              Attempting to store a property on a primitive value will fail and throw an error.
              In the first example below the <a>key path</a> for the object store is "<code>foo</code>".
              The actual object is a primitive with the value, <code>4</code>.
              Trying to define a property on that primitive value fails.
              The same is true for arrays.  Properties are not allowed on an array.
              In the second example below, the actual object is an array, <code>[10]</code>.
              Trying to define a property on the array fails.
            </p>
            <pre class="example highlight">
var store = db.createObjectStore("store", { keyPath: "foo", autoIncrement: true });

// The key generation will attempt to create and store the key path property on this primitive.
store.put(4); // will throw DataError

// The key generation will attempt to create and store the key path property on this array.
store.put([10]); // will throw DataError
            </pre>
          </aside>
        </section> <!-- key-generator-construct -->

        <section class="section">
          <h3>Exceptions</h3>
          <p>
            Each of the exceptions defined in this document is a <a><code>DOMException</code></a> with a specific type.
            The exception types and properties such as code value are defined in [[!WEBIDL]].
          </p>
          <table>
            <tr>
              <th>Type</th>
              <th>Description</th>
            </tr>
	    <tr>
	      <td><code><dfn>AbortError</dfn></code></td>
	      <td>A request was aborted.</td>
	    </tr>
            <tr>
              <td><code><dfn>ConstraintError</dfn></code></td>
	      <td>A mutation operation in the transaction failed because a constraint was not satisfied.</td>
            </tr>
            <tr>
              <td><code><dfn>DataCloneError</dfn></code></td>
	      <td>The data being stored could not be cloned by the internal structured cloning algorithm.</td>
            </tr>
            <tr>
              <td><code><dfn>DataError</dfn></code></td>
	      <td>Data provided to an operation does not meet requirements.</td>
            </tr>
	    <tr>
	      <td><code><dfn>InvalidAccessError</dfn></code></td>
	      <td>An invalid operation was performed on an object.</td>
	    </tr>
	    <tr>
	      <td><code><dfn>InvalidStateError</dfn></code></td>
	      <td>
		An operation was called on an object on which it is not allowed or at a time when it is not allowed,
                or if a request is made on a source object that has been deleted or removed.
	      </td>
	    </tr>
	    <tr>
	      <td><code><dfn>NotFoundError</dfn></code></td>
	      <td>
		The operation failed because the requested database object could not be found.
	      </td>
	    </tr>
	    <tr>
	      <td><code><dfn>QuotaExceededError</dfn></code></td>
	      <td>
		The operation failed because there was not enough remaining storage space,
		or the storage quota was reached and the user declined to give more space to the database.
	      </td>
	    </tr>
	    <tr>
	      <td><code><dfn>SyntaxError</dfn></code></td>
	      <td>The keyPath argument contains an invalid key path.</td>
	    </tr>
            <tr>
              <td><code><dfn>ReadOnlyError</dfn></code></td>
	      <td>The mutating operation was attempted in a read-only transaction.</td>
            </tr>
            <tr>
              <td><code><dfn>TransactionInactiveError</dfn></code></td>
	      <td>A request was placed against a transaction which is currently not active, or which is finished.</td>
            </tr>
            <tr>
              <td><code><dfn>UnknownError</dfn></code></td>
              <td>The operation failed for reasons unrelated to the database itself and not covered by any other errors.</td>
            </tr>
            <tr>
              <td><code><dfn>VersionError</dfn></code></td>
	      <td>An attempt was made to open a database using a lower version than the existing version.</td>
            </tr>
	  </table>

          <aside class="note">
            Given that multiple Indexed DB operations can throw the same type of error, and that
            a even single operation can throw the same type of error for multiple reasons,
            implementations are encouraged to provide more specific messages to enable developers
            to identify the cause of errors.
          </aside>
        </section> <!-- Exceptions -->
      </section>

      <section class="section" id="async-api">
        <h3>API</h3>
        <p>
          The API methods return without blocking the calling thread.
          All asynchronous operations immediately return an <a>IDBRequest</a> instance.
          This object does not initially contain any information about the result of the operation.
          Once information becomes available, an event is fired on the request and the information becomes
          available through the properties of the <a>IDBRequest</a> instance.
        </p>

        <p>
          The <span>task source</span> for these tasks is the
          <dfn id="database-access-task-source">database access task source</dfn>.
        </p>

        <section class="section" id="request-api">
          <h4>The <code>IDBRequest</code> interface</h4>
          <p>
            The <a>IDBRequest</a> interface provides the means to access results of
            asynchronous requests to <a title="database">databases</a> and <a>database</a>
            objects using <a>event handler attributes</a> [[!HTML5]].
          </p>

          <p>
            Every method for making asynchronous requests returns an
            <a>IDBRequest</a> object that communicates back to the requesting
            application through events.
            This design means that any number of requests can be active on any <a>database</a>
            at a time.
          </p>

          <aside class="example">
            <p>
              In the following example, we open a <a>database</a> asynchronously. Various
              event handlers are registered for responding to various situations.
            </p>
            <pre class="example highlight">
 var request = indexedDB.open('AddressBook', 15);
 request.onsuccess = function(evt) {...};
 request.onerror = function(evt) {...};
            </pre>
          </aside>
          <dl class="idl" title="[Exposed=(Window,Worker)] interface IDBRequest : EventTarget">
            <dt>readonly attribute any result</dt>
            <dd>
              If the <a title="request done">done flag</a> is unset,
              the <code>result</code> attribute's getter
              <a title="throw">throws</a> an <a>InvalidStateError</a> exception.
              Otherwise,
              the <code>result</code> attribute's getter
              must return the <a title="request result">result</a> of
              the request, or undefined if the request resulted in an error.
            </dd>

            <dt>readonly attribute DOMException error</dt>
            <dd>
              If the <a title="request done">done flag</a> is unset,
              the <code>error</code> attribute's getter
              <a title="throw">throws</a> an <a>InvalidStateError</a> exception.
              Otherwise,
              the <code>error</code> attribute's getter
              must return the <a title="request error">error</a> of the request,
              or null if no error occurred.
            </dd>

            <dt>readonly attribute (IDBObjectStore or IDBIndex or IDBCursor)? source</dt>
            <dd>
              The <code>source</code> attribute's getter
              must return the <a title="request source">source</a> of the <a>request</a>, or
              null if no <a title="request source">source</a> is set.
            </dd>

            <dt>readonly attribute IDBTransaction transaction</dt>
            <dd>
              The <code>transaction</code> attribute's getter
              must return the <a title="request transaction">transaction</a> of the <a>request</a>.
              This property can be null for certain requests, such as for <a>request</a>
              returned from <a href="#widl-IDBFactory-open-IDBOpenDBRequest-DOMString-name-unsigned-long-long-version"><code>IDBFactory.open</code></a>.
            </dd>

            <dt>readonly attribute IDBRequestReadyState readyState</dt>
            <dd>
              The <code>readyState</code> attribute's getter
              must return "<code>pending</code>" if the <a title="request done">done flag</a> is unset,
              and "<code>done</code>" otherwise.</dd>

            <dt>attribute EventHandler onsuccess</dt>
            <dd>The event handler for the <code>success</code> event.</dd>
            <dt>attribute EventHandler onerror</dt>
            <dd>The event handler for the <code>error</code> event.</dd>
          </dl>
          <p>
            Methods on <a>IDBFactory</a> that return a <a>open request</a> use
            an extended interface to allow listening to the
            <code>blocked</code> event and <code>upgradeneeded</code> event.
          </p>

          <dl class="idl" title="[Exposed=(Window,Worker)] interface IDBOpenDBRequest : IDBRequest">
            <dt>attribute EventHandler onblocked</dt>
            <dd>The event handler for the <code>blocked</code> event.</dd>
            <dt>attribute EventHandler onupgradeneeded</dt>
            <dd>The event handler for the <code>upgradeneeded</code> event.</dd>
          </dl>

          <dl class="idl" title="enum IDBRequestReadyState">
            <dt>pending</dt>
            <dd>The <a title="request done">done flag</a> of the <a>request</a> is unset.</dd>
            <dt>done</dt>
            <dd>The <a title="request done">done flag</a> of the <a>request</a> is set.</dd>
          </dl>
        </section>

        <section class="section" id="events">
          <h4>Event interfaces</h4>
          <p>
            This specification fires events with the following custom interfaces:
          </p>

          <dl class="idl" title="[Exposed=(Window,Worker), Constructor(DOMString type, optional IDBVersionChangeEventInit eventInitDict)] interface IDBVersionChangeEvent : Event">
            <dt>readonly attribute unsigned long long oldVersion</dt>
            <dd>The previous version of the database.
            <dt>readonly attribute unsigned long long? newVersion</dt>
            <dd>The new version of the database, or null if the database is being deleted.
            See the <a>steps for running an upgrade transaction</a>.</dd>
          </dl>
          <p>
            The
            <a href="#widl-IDBVersionChangeEvent-oldVersion"><code>oldVersion</code></a>
            and <a href="#widl-IDBVersionChangeEvent-newVersion"><code>newVersion</code></a> attributes
            must return the value they were initialized to.
          </p>
          <p>
          	Events are constructed as defined in <a href="http://dvcs.w3.org/hg/domcore/raw-file/tip/Overview.html#constructing-events">Constructing events</a>,
          	in [[!DOM4]].
          </p>
          <dl class="idl" title="dictionary IDBVersionChangeEventInit : EventInit">
            <dt>unsigned long long oldVersion = 0
            <dd>
            <dt>unsigned long long? newVersion = null
            <dd>
          </dl>

          <p>
            To <dfn title="fire a version change event">fire a version change event named <var>e</var></dfn> at <var>target</var>
            given <var>oldVersion</var> and <var>newVersion</var>,
            dispatch an event at <var>target</var>.

            The event MUST use the <a>IDBVersionChangeEvent</a> interface
            with its <code>type</code> set to <var>e</var>,
            its <a href="#widl-IDBVersionChangeEvent-oldVersion"><code>oldVersion</code></a> attribute set to <var>oldVersion</var>, and
            its <a href="#widl-IDBVersionChangeEvent-newVersion"><code>newVersion</code></a> attribute set to <var>newVersion</var>.
            This event MUST NOT bubble or be cancelable. The propagation path for the event is just <var>target</var>.
          </p>
        </section>

        <section class="section" id="factory-interface">
          <h4>The <code>IDBFactory</code> interface</h4>
          <p>
            <a>Database</a> objects are accessed through methods on the
            <a>IDBFactory</a> interface.
            A single object implementing this interface is present in the global scope of environments
            that support Indexed DB operations.
          </p>

          <dl class="idl" title="[NoInterfaceObject] interface IDBEnvironment">
            <dt>readonly attribute IDBFactory indexedDB</dt>
            <dd>This attribute provides applications a mechanism for accessing
              capabilities of indexed databases.</dd>
          </dl>
          <p class="idl" title="Window implements IDBEnvironment"></p>
          <p class="idl" title="WorkerUtils implements IDBEnvironment"></p>


          <dl class="idl" title="[Exposed=(Window,Worker)] interface IDBFactory">
            <dt>IDBOpenDBRequest open()</dt>
            <dd>
              The <code>open(<var>name</var>, <var>version</var>)</code> method, when invoked, must run these steps:
              <ol>
                <li>
                  If <var>version</var> is 0 (zero), <a>throw</a> a <code>TypeError</code>.
                </li>
                <li>
                  Let <var>request</var> be a new <a>open request</a>.
                </li>
                <li>
                  <a>Queue a task</a> to run these substeps:
                  <ol>
                    <li>Let <var>result</var> be the result of running the <a>steps for opening a database</a>, with
                      the origin of the <a>IDBEnvironment</a> used to access this <a>IDBFactory</a>,
                      <var>name</var>,
                      <var>version</var> if given and undefined otherwise, and
                      <var>request</var>.
                      <aside class="note">
                        If <var>version</var> is not given and a <a>database</a> with that name already exists,
                        a connection will be opened without changing the <a>version</a>. If <var>version</var>
                        is not given and no <a>database</a> with that name exists, a new <a>database</a>
                        will be created with <a>version</a> equal to <code>1</code>.
                      </aside>
                    </li>
                    <li>
                      If <var>result</var> is an error, set the
                      <a title="request error">error</a> of <var>request</var> to <var>result</var>
                      and dispatch an event at <var>request</var>.
                      The event must use the <code>Event</code> interface and set the <code>type</code> attribute
                      to "<code>error</code>". The event does bubble but is not cancelable. The <a>propagation path</a>
                      of the event is just <var>request</var>.
                    </li>
                    <li>
                      Otherwise, set the <a title="request result">result</a> of <var>request</var> to
                      <var>result</var> and dispatch an event at <var>request</var>.
                      The event must use the <code>Event</code> interface and set the <code>type</code> attribute
                      to "<code>success</code>". The event does not bubble and is not cancelable. The <a>propagation path</a>
                      of the event is just <var>request</var>.

                      If the steps above resulted in an <a>upgrade transaction</a> being
                      run, then firing the "<code>success</code>" event MUST be done after the <a>upgrade transaction</a> completes.

                      <aside class="note">
                        The last requirement is to ensure that in case another version upgrade is about to happen,
                        the success event is fired on the connection first so that the script gets a chance to register
                        a listener for the <code>versionchange</code> event.
                      </aside>

                      <aside class="note">
                        The firing of "<code>success</code>" or "<code>error</code>" events do not follow the normal
                        steps to <a>fire a success event</a> or <a>fire an error event</a> as there is no active
                        transaction at the time when they fire.
                      </aside>
                    </li>
                  </ol>
                </li>
                <li>
                  Return a new <a>IDBOpenDBRequest</a> object for <var>request</var>.
                </li>
              </ol>
              <dl class="parameters">
                <dt>DOMString name</dt>
                <dd>The <a title="database name">name</a> for the <a>database</a></dd>
                <dt>[EnforceRange] optional unsigned long long version</dt>
                <dd>The <a>version</a> for the <a>database</a></dd>
              </dl>
            </dd>

            <dt>IDBOpenDBRequest deleteDatabase()</dt>
            <dd>
              The <code>deleteDatabase(<var>name</var>)</code> method, when invoked, must run these steps:
              <ol>
                <li>
                  Let <var>request</var> be a new <a>open request</a>.
                </li>
                <li>
                  <a>Queue a task</a> to run these substeps:
                  <ol>
                    <li>Let <var>result</var> be the result of running the <a>steps for deleting a database</a>, with
                      the origin of the <a>IDBEnvironment</a> used to access this <a>IDBFactory</a>,
                      <var>name</var>, and
                      <var>request</var>.
                    </li>
                    <li>
                      If <var>result</var> is an error
                      set the <a title="request error">error</a> of <var>request</var> to <var>result</var>
                      and dispatch an event at <var>request</var>.
                      The event must use the <code>Event</code> interface and set the <code>type</code> attribute
                      to "<code>error</code>". The event does bubble but is not cancelable. The <a>propagation
                      path</a> of the event is just <var>request</var>.
                    </li>
                    <li>
                      Otherwise, set the <a title="request result">result</a> of <var>request</var> to undefined and
                      <a title="fire a version change event">fire a version change event named <code>success</code></a>
                      at <a>request</a> with <var>result</var> and null.

                      <aside class="note">
                        The firing of "<code>success</code>" or "<code>error</code>" events do not follow the normal
                        steps to <a>fire a success event</a> or <a>fire an error event</a> as there is no active
                        transaction at the time when they fire.
                      </aside>
                    </li>
                  </ol>
                </li>
                <li>
                  Return a new <a>IDBOpenDBRequest</a> object for <var>request</var>.
                </li>
              </ol>
              <dl class="parameters">
                <dt>DOMString name</dt>
                <dd>The <a title="database name">name</a> of the <a>database</a> to delete</dd>
              </dl>
            </dd>

            <dt>short cmp()</dt>
            <dd>
              The <code>cmp(<var>first</var>, <var>second</var>)</code> method, when invoked, must run these steps:
              <ol>
                <li>Let <var>a</var> be the result of running the steps to <a>convert a value to a key</a> with <var>first</var>.
                  If this throws an exception, <a title="throw">rethrow</a> it.</li>
                <li>If <var>a</var> is invalid, <a>throw</a> a <a>DataError</a> exception.</li>

                <li>Let <var>b</var> be the result of running the steps to <a>convert a value to a key</a> with <var>second</var>.
                  If this throws an exception, <a title="throw">rethrow</a> it.</li>
                <li>If <var>b</var> is invalid, <a>throw</a> a <a>DataError</a> exception.</li>

                <li>Return the results of running the steps to <a>compare two keys</a> with <var>a</var> and <var>b</var>.</li>
              </ol>

              <dl class="parameters">
                <dt>any first</dt>
                <dd>The first <a>key</a> to compare.</dd>
                <dt>any second</dt>
                <dd>The second <a>key</a> to compare.</dd>
              </dl>
            </dd>
          </dl>
        </section>

        <section id="database-interface" class="section">
          <h4>The <code>IDBDatabase</code> interface</h4>
          <!-- TODO Add example. Should examples be in a separate section?-->
          <p>
            The <a>IDBDatabase</a>
            interface represents a <a>connection</a> to a <a>database</a>.
          </p>

          <p>
            An <a>IDBDatabase</a> object MUST NOT be garbage collected if its
            associated <a>connection</a>'s <a>close pending flag</a> is unset
            and it has one or more event listeners registers whose type is one of
            <code>abort</code>, <code>error</code>, or <code>versionchange</code>.

            If an <a>IDBDatabase</a> object is garbage collected, the
            associated <a>connection</a> must be <a title="database close">closed</a>.
          </p>

          <dl class="idl" title="[Exposed=(Window,Worker)] interface IDBDatabase : EventTarget">
            <dt>readonly attribute DOMString name</dt>
            <dd>
              The <code>name</code> attribute's getter must return the <a title="database name">name</a>
              of the <a title="connection">connected</a> <a>database</a>. The attribute MUST
              return this name even if the <a>close pending flag</a> is set on the <a>connection</a>.
              In other words, the value of this attribute
              stays constant for the lifetime of the <a>IDBDatabase</a> instance.
            </dd>

            <dt>readonly attribute unsigned long long version</dt>
            <dd>
              The <code>version</code> attribute's getter must return this
              <a>connection</a>'s <a title="connection version">version</a>.

              <aside class="note">
                As long as the <a>connection</a> is open, this is the same as the
                connected <a>database</a>'s <a>version</a>.

                Once the <a>connection</a> has <a title="database close">closed</a>,
                this attribute will not reflect changes made with a later <a>upgrade transaction</a>.
              </aside>
            </dd>

            <dt>readonly attribute DOMStringList objectStoreNames</dt>
            <dd>
              The <code>objectStoreNames</code> attribute's getter must return a
              <a>sorted list</a> of the <a title="object store name">names</a> of the
              <a title="object store">object stores</a> in this <a>connection</a>'s
              <a>object store set</a>.

              <aside class="note">
                As long as the <a>connection</a> is open, this is the same as the
                connected <a>database</a>'s <a>object store</a> <a title="object store name">names</a>.

                Once the <a>connection</a> has <a title="database close">closed</a>,
                this attribute will not reflect changes made with a later <a>upgrade transaction</a>.
              </aside>
            </dd>

            <dt>IDBObjectStore createObjectStore()</dt>
            <dd>
              <p>
                This method creates and returns a new <a>object store</a> with the given name in the
                <a title="connection">connected</a> <a>database</a>.
                Note that this method must only be called from within an <a>upgrade transaction</a>.
              </p>

              The <code>createObjectStore(<var>name</var>, <var>options</var>)</code> method, when invoked, must run these steps:
              <ol>
                <li>Let <var>database</var> be the <a>database</a> associated with this <a>connection</a>.
                <li>Let <var>transaction</var> be the currently running <a>upgrade transaction</a> associated with
                  <var>database</var>, or <a>throw</a> an <a>InvalidStateError</a> exception if none.
                </li>
                <li>If <var>transaction</var> is not <a>active</a>,
                  <a>throw</a> a <a>TransactionInactiveError</a> exception.
                </li>
                <li>If an <a>object store</a> <a title="object store name">named</a> <var>name</var> already exists in
                  <var>database</var>
                  <a>throw</a> a <a>ConstraintError</a> exception.
                </li>

                <li>Let <var>keyPath</var> be <var>options</var>'s <code>keyPath</code> member if it is not undefined or null, or null otherwise.</li>
                <li>If <var>keyPath</var> is not null and is not a <a>valid key path</a>,
                  <a>throw</a> a <a>SyntaxError</a> exception.
                </li>

                <li>Let <var>autoIncrement</var> be set if <var>options</var>'s <code>autoIncrement</code> member is true, or unset otherwise.</li>
                <li>If <var>autoIncrement</var> is set and <var>keyPath</var> is an empty string or any sequence (empty or otherwise),
                  <a>throw</a> an <a>InvalidAccessError</a> exception.
                </li>

                <li>
                  Let <var>store</var> be a new <a>object store</a> in <var>database</var>.
                  Set the created <a>object store</a>'s <a title="object store name">name</a> to <var>name</var>.
                  If <var>autoIncrement</var> is set, then the created <a>object store</a> uses a <a>key generator</a>.
                  If <var>keyPath</var> is not null, set the created <a>object store</a>'s <a title="object store key path">key path</a> to <var>keyPath</var>.
                </li>

                <li>
                  Return a new <a>object store handle</a> associated with <var>store</var> and <var>transaction</var>.
                </li>
              </ol>

              <p>
                This method synchronously modifies the
                <a href="#widl-IDBDatabase-objectStoreNames"><code>objectStoreNames</code></a> property
                on the <a>IDBDatabase</a> instance on which it was called.
              </p>

              <p>
                In some implementations it is possible for the implementation to run into problems
                after queuing a task to create the <a>object store</a> after the <code>createObjectStore()</code> method has returned.
                For example in implementations where metadata about the newly created <a>object store</a> is inserted into the database asynchronously,
                or where the implementation might need to ask the user for permission for quota reasons.
                Such implementations MUST still create and return an <a>IDBObjectStore</a> object, and
                once the implementation determines that creating the <a>object store</a> has failed, it MUST abort the transaction
                using the <a>steps for aborting a transaction</a> using the appropriate error. For example if
                creating the <a>object store</a> failed due to quota reasons, <a>QuotaExceededError</a> MUST be used as error.
              </p>

              <dl class="parameters">
                <dt>DOMString name</dt>
                  <dd>The <a title="object store name">name</a> of a new <a>object store</a></dd>
                <dt>optional IDBObjectStoreParameters options</dt>
                  <dd>A dictionary of optional parameters to this method.
                    <code>keyPath</code> specifies the <a title="object store key path">key path</a> of the new
                    <a>object store</a>. If the attribute is null,
                    no <a title="object store key path">key path</a> is
                    specified and thus keys are <a title="out-of-line keys">out-of-line</a>.
                    <code>autoIncrement</code> specifies whether the <a>object store</a>
                    created should have a <a>key generator</a>.</dd>
              </dl>
            </dd>

            <dt>void deleteObjectStore()</dt>
            <dd>
              <p>
                This method destroys the <a>object store</a> with the given name in the
                <a title="connection">connected</a> <a>database</a>.
                Note that this method must only be called from within an <a>upgrade transaction</a>.
              </p>

              The <code>deleteObjectStore(<var>name</var>)</code> method, when invoked, must run these steps:
              <ol>
                <li>Let <var>database</var> be the <a>database</a> associated with this <a>connection</a>.
                <li>Let <var>transaction</var> be the currently running <a>upgrade transaction</a> associated with
                  <var>database</var>, or <a>throw</a> an <a>InvalidStateError</a> exception if none.
                </li>
                <li>If <var>transaction</var> is not <a>active</a>,
                  <a>throw</a> a <a>TransactionInactiveError</a> exception.
                </li>
                <li>Let <var>store</var> be the <a>object store</a> <a title="object store name">named</a> <var>name</var> in <var>database</var>,
                  or <a>throw</a> a <a>NotFoundError</a> exception if none.
                </li>
                <li>
                  Remove <var>store</var> from this <a>connection</a>'s <a>object store set</a>.
                </li>
                <li>
                  Destroy <var>store</var>.
                </li>
              </ol>

              <p>
                This method synchronously modifies the
                <a href="#widl-IDBDatabase-objectStoreNames"><code>objectStoreNames</code></a> property
                on the <a>IDBDatabase</a> instance on which it was called.
              </p>
              <dl class="parameters">
                <dt>DOMString name</dt>
                <dd>The <a title="object store name">name</a> of an existing
                <a>object store</a></dd>
              </dl>
            </dd>

            <dt>IDBTransaction transaction()</dt>
            <dd>
              The <code>transaction(<var>storeNames</var>, <var>mode</var>)</code> method, when invoked, must run these steps:
              <ol>
                <li>If <var>mode</var> parameter is not "<code>readonly</code>" or "<code>readwrite</code>",
                  <a>throw</a> a <code>TypeError</code>.
                </li>
                <li>If this method is called on <a>IDBDatabase</a> object for which an <a>upgrade transaction</a> is still running,
                  <a>throw</a> an <a>InvalidStateError</a> exception.
                </li>
                <li>If this method is called on an <a>IDBDatabase</a> instance where the <a>close pending flag</a> is set,
                  <a>throw</a> an <a>InvalidStateError</a> exception.
                </li>
                <li>
                  Let <var>scope</var> be the set of unique strings in <var>storeNames</var> if it is a sequence,
                  or a set containing one string equal to <var>storeNames</var> otherwise.
                </li>
                <li>If any string in <var>scope</var> is not the name of an <a>object store</a> in the <a title="connection">connected</a> <a>database</a>,
                  <a>throw</a> a <a>NotFoundError</a> exception.
                </li>
                <li>If <var>scope</var> is empty,
                  <a>throw</a> an <a>InvalidAccessError</a> exception.
                </li>

                <li>Let <var>transaction</var> be a <a title="transaction create">new transaction</a>
                  with <var>connection</var>, <var>mode</var> and the set of <a title="object store">object stores</a> named in <var>scope</var>.
                </li>
                <li>
                  When control is returned to the event loop, the implementation MUST unset the <a>active flag</a>.
                  <aside class="issue">Specify this more precisely in terms of tasks and microtasks.</aside>
                </li>
                <li>
                  Return an <a>IDBTransaction</a> object representing <var>transaction</var>.
                </li>
              </ol>

              <aside class="note">
                The created <var>transaction</var> will follow the <a>transaction lifetime</a> rules.
              </aside>

              <dl class="parameters">
                <dt>(DOMString or sequence&lt;DOMString&gt;) storeNames</dt>
                <dd>The names of <a title="object store">object stores</a> in the <a>scope</a> of the new
                <a>transaction</a></dd>
                <dt>optional IDBTransactionMode mode = "readonly"</dt>
                <dd> The <a>mode</a> for isolating access to data inside the given
                <a title="object store">object stores</a>. If this parameter is not given, the default
                access <a>mode</a> is "<code>readonly</code>".</dd>
              </dl>
            </dd>

            <dt>void close()</dt>
            <dd>
              The <code>close()</code> method, when invoked, must run these steps:
              <ol>
                <li>Run the <a>steps for closing a database connection</a> with this <a>connection</a>.</li>
              </ol>
            </dd>
            <dt>attribute EventHandler onabort</dt>
            <dd>The event handler for the <code>abort</code> event.</dd>
            <dt>attribute EventHandler onclose</dt>
            <dd>The event handler for the <code>close</code> event.
              <aside class="note">&#9752; This attribute is new in this edition. &#9752;</aside>
            </dd>
            <dt>attribute EventHandler onerror</dt>
            <dd>The event handler for the <code>error</code> event.</dd>
            <dt>attribute EventHandler onversionchange</dt>
            <dd>The event handler for the <code>versionchange</code> event.</dd>
          </dl>
        </section>

        <section class="section" id="object-store">
          <h4>The <code>IDBObjectStore</code> interface</h4>
          <p>
            The <a>IDBObjectStore</a>
            interface represents an <a>object store handle</a>.
          </p>
          <dl class="idl" title="[Exposed=(Window,Worker)] interface IDBObjectStore">
            <dt>attribute DOMString name</dt>
            <dd>
              <p>
                The <code>name</code> attribute's getter must return this
                <a>object store handle</a>'s <a title="handle object store">object store</a>'s <a title="object store name">name</a>.

                <aside class="note">
                  As long as the <a>transaction</a> has not <a title="transaction finish">finished</a>,
                  this is the same as the associated <a>object store</a>'s <a title="object store name">name</a>.

                  Once the <a>transaction</a> has <a title="transaction finish">finished</a>,
                  this attribute will not reflect changes made with a later <a>upgrade transaction</a>.
                </aside>
              </p>

              <p>
                The <code>name</code> attribute's setter must run these steps:
                <aside class="note">&#9752; This setter is new in this edition. &#9752;</aside>
              </p>
              <ol>
                <li>Let <var>name</var> be the given value.</li>

                <li>Let <var>transaction</var> be this <a>object store handle</a>'s <a title="object store handle transaction">transaction</a>.</li>

                <li>Let <var>store</var> be this <a>object store handle</a>'s <a title="handle object store">object store</a>.</li>

                <li>If <var>store</var> has been deleted,
                  <a>throw</a> an <a>InvalidStateError</a> exception.
                </li>

                <li>If <var>transaction</var> is not an <a>upgrade transaction</a>,
                  <a>throw</a> an <a>InvalidStateError</a> exception.
                </li>

                <li>If <var>transaction</var> is not <a>active</a>,
                  <a>throw</a> a <a>TransactionInactiveError</a> exception.
                </li>

                <li>If <var>store</var>'s <a title="object store name">name</a> is equal to <var>name</var>, terminate these steps.</li>

                <li>
                  If an <a>object store</a> <a title="object store name">named</a> <var>name</var> already exists in
                  <var>store</var>'s <a>database</a>,
                  <a>throw</a> a <a>ConstraintError</a> exception.
                </li>

                <li>
                  Set <var>store</var>'s <a title="object store name">name</a> to <var>name</var>.
                </li>
                <li>
                  Set this <a>object store handle</a>'s <a title="object store handle name">name</a> to <var>name</var>.
                </li>
              </ol>
            </dd>

            <dt>readonly attribute any keyPath</dt>
            <dd>
              <p>
                The <code>keyPath</code> attribute's getter must return this
                <a>object store handle</a>'s <a title="handle object store">object store</a>'s <a title="object store key path">key path</a>,
                or null if none.
              </p>
              <p>
                The conversion is done following the normal [[!WEBIDL]] binding logic for
                <a>DOMString</a> and <a>sequence&lt;DOMString&gt;</a> values,
                as appropriate.
              </p>
              <p>
                The returned value is not the same instance that was used when the <a>object store</a>
                was created. However, if this attribute returns an object (specifically an <code>Array</code>),
                it returns the same object instance every time it is inspected. Changing
                the properties of the object has no effect on the <a>object store</a>.
              </p>
            </dd>

            <dt>readonly attribute DOMStringList  indexNames</dt>
            <dd>
              The <code>indexNames</code> attribute's getter must return
              a <a>sorted list</a> of the <a title="index name">names</a> of <a title="index">indexes</a>
              in this <a>object store handle</a>'s <a>index set</a>.

              <aside class="note">
                As long as the <a>transaction</a> has not <a title="transaction finish">finished</a>,
                this is the same as the associated
                <a>object store</a>'s list of <a>index</a> <a title="index name">names</a>.

                Once the <a>transaction</a> has <a title="transaction finish">finished</a>,
                this attribute will not reflect changes made with a later <a>upgrade transaction</a>.
              </aside>
            </dd>

            <dt>readonly attribute IDBTransaction transaction</dt>
            <dd>
              The <code>transaction</code> attribute's getter must return this
              <a>object store handle</a>'s <a title="object store handle transaction">transaction</a>,
            </dd>

            <dt>readonly attribute boolean autoIncrement</dt>
            <dd>
              The <code>autoIncrement</code> attribute's getter must return true
              if this <a>object store handle</a>'s <a title="handle object store">object store</a>
              has a <a>key generator</a>, and false otherwise.
            </dd>

            <dt>IDBRequest put()</dt>
            <dd>
              The <code>put(<var>value</var>, <var>key</var>)</code> method, when invoked, must run these steps:
              <ol>
                <li>Let <var>transaction</var> be this <a>object store handle</a>'s <a title="object store handle transaction">transaction</a>.</li>

                <li>Let <var>store</var> be this <a>object store handle</a>'s <a title="handle object store">object store</a>.</li>

                <li>If <var>store</var> has been deleted,
                  <a>throw</a> an <a>InvalidStateError</a> exception.</li>

                <li>If <var>transaction</var> is not <a>active</a>,
                  <a>throw</a> a <a>TransactionInactiveError</a> exception.</li>

                <li>If <var>transaction</var> is a <a>read-only transaction</a>,
                  <a>throw</a> a <a>ReadOnlyError</a> exception.</li>

                <li>If <var>store</var> uses <a>in-line keys</a> and <var>key</var> was given,
                  <a>throw</a> a <a>DataError</a> exception.</li>

                <li>If <var>store</var> uses <a>out-of-line keys</a> and has no <a>key generator</a>
                  and <var>key</var> was not given,
                  <a>throw</a> a <a>DataError</a> exception.</li>

                <li>If <var>key</var> was given:
                  <ol>
                    <li>Let <var>r</var> be the result of running the steps to <a>convert a value to a key</a> with <var>key</var>.
                      If this throws an exception, <a title="throw">rethrow</a> it.</li>
                    <li>If <var>r</var> is invalid, <a>throw</a> a <a>DataError</a> exception.</li>
                    <li>Let <var>key</var> be <var>r</var>.
                  </ol>
                </li>

                <li>Let <var>clone</var> be <a>structured clone</a> of <var>value</var>. If this
                  throws an exception, <a title="throw">rethrow</a> the exception.</li>

                <li>If <var>store</var> uses <a>in-line keys</a>:
                  <ol>
                    <li>Let <var>kpk</var> be the result of running the steps to <a>extract a key from a value using a key path</a>
                      with <var>clone</var> and <var>store</var>'s <a title="object store key path">key path</a>.
                      If this throws an exception, <a title="throw">rethrow</a> it.</li>
                    <li>If <var>kpk</var> is invalid, <a>throw</a> a <a>DataError</a> exception.</li>
                    <li>If <var>kpk</var> is not failure, let <var>key</var> be <var>kpk</var>.</li>
                    <li>Otherwise, if <var>store</var> does not have a <a>key generator</a>,
                      <a>throw</a> a <a>DataError</a> exception.</li>
                  </ol>
                </li>

                <li>Run the <a>steps for asynchronously executing a request</a> and return the <a>IDBRequest</a> created by these steps.
                  The steps are run with this <a>object store handle</a> as <var>source</var> and the <a>steps for
                  storing a record into an object store</a> as <var>operation</var>, using
                  <var>store</var>, the <var>clone</var> as <var>value</var>,
                  <var>key</var>, and with the <var>no-overwrite flag</var> unset.
                </li>
              </ol>

              <dl class="parameters">
                <dt>any value</dt>
                <dd>The value to be stored in the <a>record</a></dd>
                <dt>optional any key</dt>
                <dd>The key used to identify the <a>record</a></dd>
              </dl>
            </dd>

            <dt>IDBRequest add()</dt>
            <dd>
              The <code>add(<var>value</var>, <var>key</var>)</code> method, when invoked, must run these steps:
              <ol>
                <li>Let <var>transaction</var> be this <a>object store handle</a>'s <a title="object store handle transaction">transaction</a>.</li>

                <li>Let <var>store</var> be this <a>object store handle</a>'s <a title="handle object store">object store</a>.</li>

                <li>If <var>store</var> has been deleted,
                  <a>throw</a> an <a>InvalidStateError</a> exception.</li>

                <li>If <var>transaction</var> is not <a>active</a>,
                  <a>throw</a> a <a>TransactionInactiveError</a> exception.</li>

                <li>If <var>transaction</var> is a <a>read-only transaction</a>,
                  <a>throw</a> a <a>ReadOnlyError</a> exception.</li>

                <li>If <var>store</var> uses <a>in-line keys</a> and <var>key</var> was given,
                  <a>throw</a> a <a>DataError</a> exception.</li>

                <li>If <var>store</var> uses <a>out-of-line keys</a> and has no <a>key generator</a>
                  and <var>key</var> was not given,
                  <a>throw</a> a <a>DataError</a> exception.</li>

                <li>If <var>key</var> was given:
                  <ol>
                    <li>Let <var>r</var> be the result of running the steps to <a>convert a value to a key</a> with <var>key</var>.
                      If this throws an exception, <a title="throw">rethrow</a> it.</li>
                    <li>If <var>r</var> is invalid, <a>throw</a> a <a>DataError</a> exception.</li>
                    <li>Let <var>key</var> be <var>r</var>.
                  </ol>
                </li>

                <li>Let <var>clone</var> be <a>structured clone</a> of <var>value</var>. If this
                  throws an exception, <a title="throw">rethrow</a> the exception.</li>

                <li>If <var>store</var> uses <a>in-line keys</a>:
                  <ol>
                    <li>Let <var>kpk</var> be the result of running the steps to <a>extract a key from a value using a key path</a>
                      with <var>clone</var> and <var>store</var>'s <a title="object store key path">key path</a>.
                      If this throws an exception, <a title="throw">rethrow</a> it.</li>
                    <li>If <var>kpk</var> is invalid, <a>throw</a> a <a>DataError</a> exception.</li>
                    <li>If <var>kpk</var> is not failure, let <var>key</var> be <var>kpk</var>.</li>
                    <li>Otherwise, if <var>store</var> does not have a <a>key generator</a>,
                      <a>throw</a> a <a>DataError</a> exception.</li>
                  </ol>
                </li>
                <li>
                  Run the <a>steps for asynchronously executing a request</a> and return the <a>IDBRequest</a> created by these steps.
                  The steps are run with this <a>object store handle</a> as <var>source</var> and the <a>steps for
                  storing a record into an object store</a> as <var>operation</var>, using
                  <var>store</var>, <var>clone</var> as <var>value</var>,
                  <var>key</var>, and with the <var>no-overwrite flag</var> set.
                </li>
              </ol>
              <aside class="note">
            	To determine if a <a>transaction</a> has completed successfully,
            	listen to the <a title="transaction">transaction’s</a> <code>complete</code> event rather than the <a>request</a>’s <code>success</code> event,
            	because the <a>transaction</a> may still fail after the <code>success</code> event fires.
              </aside>
              <dl class="parameters">
                <dt>any value</dt>
                <dd>The value to be stored in the <a>record</a></dd>
                <dt>optional any key</dt>
                <dd>The key used to identify the <a>record</a></dd>
              </dl>
            </dd>

            <dt>IDBRequest delete()</dt>
            <dd>
              The <code>delete(<var>query</var>)</code> method, when invoked, must run these steps:
              <ol>
                <li>Let <var>transaction</var> be this <a>object store handle</a>'s <a title="object store handle transaction">transaction</a>.</li>

                <li>Let <var>store</var> be this <a>object store handle</a>'s <a title="handle object store">object store</a>.</li>

                <li>If <var>store</var> has been deleted,
                  <a>throw</a> an <a>InvalidStateError</a> exception.</li>

                <li>If <var>transaction</var> is not <a>active</a>,
                  <a>throw</a> a <a>TransactionInactiveError</a> exception.</li>

                <li>If <var>transaction</var> is a <a>read-only transaction</a>,
                  <a>throw</a> a <a>ReadOnlyError</a> exception.</li>

                <li>Let <var>range</var> be the result of running
                  the steps to <a>convert a value to a key range</a>
                  with <var>query</var> and <var>null disallowed flag</var> set.
                  If this throws an exception, <a title="throw">rethrow</a> it.
                </li>

                <li>
                  Run the <a>steps for
                  asynchronously executing a request</a> and return the <a>IDBRequest</a> created by these steps.
                  The steps are run with this <a>object store handle</a> as <var>source</var> and the <a>steps for deleting
                  records from an object store</a> as <var>operation</var>, using
                  <var>store</var> and <var>range</var>.
                </li>
              </ol>

              <aside class="note">
                Unlike other methods which take keys or key ranges, this method does <strong>not</strong> allow null to
                be given as key. This is to reduce the risk that a small bug would clear a whole object store.
              </aside>
              <dl class="parameters">
                <dt>any query</dt>
                <dd><a>Key</a> or <a>IDBKeyRange</a> identifying the <a title="record">records</a> to be deleted.</dd>
              </dl>
            </dd>

            <dt>IDBRequest clear()</dt>
            <dd>
              The <code>clear()</code> method, when invoked, must run these steps:
              <ol>
                <li>Let <var>transaction</var> be this <a>object store handle</a>'s <a title="object store handle transaction">transaction</a>.</li>

                <li>Let <var>store</var> be this <a>object store handle</a>'s <a title="handle object store">object store</a>.</li>

                <li>If <var>store</var> has been deleted,
                  <a>throw</a> an <a>InvalidStateError</a> exception.</li>

                <li>If <var>transaction</var> is not <a>active</a>,
                  <a>throw</a> a <a>TransactionInactiveError</a> exception.</li>

                <li>If <var>transaction</var> is a <a>read-only transaction</a>,
                  <a>throw</a> a <a>ReadOnlyError</a> exception.</li>

                <li>Run the <a>steps for asynchronously executing a request</a> and return the
                  <a>IDBRequest</a> created by these steps. The steps are run with this <a>object store handle</a> as
                  <var>source</var> and the <a>steps for clearing an object store</a> as <var>operation</var>, using
                  <var>store</var>.
                </li>
              </ol>
            </dd>

            <dt>IDBRequest get()</dt>
            <dd>
              The <code>get(<var>query</var>)</code> method, when invoked, must run these steps:
              <ol>
                <li>Let <var>transaction</var> be this <a>object store handle</a>'s <a title="object store handle transaction">transaction</a>.</li>

                <li>Let <var>store</var> be this <a>object store handle</a>'s <a title="handle object store">object store</a>.</li>

                <li>If <var>store</var> has been deleted,
                  <a>throw</a> an <a>InvalidStateError</a> exception.</li>

                <li>If <var>transaction</var> is not <a>active</a>,
                  <a>throw</a> a <a>TransactionInactiveError</a> exception.</li>

                <li>Let <var>range</var> be the result of running
                  the steps to <a>convert a value to a key range</a>
                  with <var>query</var> and <var>null disallowed flag</var> set.
                  If this throws an exception, <a title="throw">rethrow</a> it.
                </li>

                <li>
                  Run the <a>steps for asynchronously executing
                  a request</a> and return the <a>IDBRequest</a> created by these steps. The steps are run with this
                  <a>object store handle</a> as <var>source</var> and the <a>steps for retrieving a value from an
                    object store</a> as <var>operation</var>, using <var>store</var> and
                  <var>range</var>.
                </li>
              </ol>

              <aside class="note">
                This method produces the same result if a record with the given key doesn't exist as when a record
                exists, but has undefined as value. If you need to tell the two situations apart, you can use
                <a href="#widl-IDBObjectStore-openCursor-IDBRequest-any-range-IDBCursorDirection-direction"><code>openCursor</code></a> with the same key. This will return a cursor with
                undefined as value if a record exists, or no cursor if no such record exists.
              </aside>
              <dl class="parameters">
                <dt>any query</dt>
                <dd>Key identifying the <a>record</a> to be retrieved. This can also be an <a>IDBKeyRange</a> in which case
                the method retrieves the first existing value in that range.</dd>
              </dl>
            </dd>

            <dt>IDBRequest getAll()</dt>
            <dd>
              <aside class="note">&#9752; This method is new in this edition. &#9752;</aside>

              The <code>getAll(<var>query</var>, <var>count</var>)</code> method, when invoked, must run these steps:
              <ol>
                <li>Let <var>transaction</var> be this <a>object store handle</a>'s <a title="object store handle transaction">transaction</a>.</li>

                <li>Let <var>store</var> be this <a>object store handle</a>'s <a title="handle object store">object store</a>.</li>

                <li>If <var>store</var> has been deleted,
                  <a>throw</a> an <a>InvalidStateError</a> exception.</li>

                <li>If <var>transaction</var> is not <a>active</a>,
                  <a>throw</a> a <a>TransactionInactiveError</a> exception.</li>

                <li>Let <var>range</var> be the result of running
                  the steps to <a>convert a value to a key range</a>
                  with <var>query</var>.
                  If this throws an exception, <a title="throw">rethrow</a> it.
                </li>

                <li>
                  Run the <a>steps for asynchronously executing
                  a request</a> and return the <a>IDBRequest</a> created by these steps. The steps are run with this
                  <a>object store handle</a> as <var>source</var> and the <a>steps for retrieving multiple values from an
                    object store</a> as <var>operation</var>, using <var>store</var>,
                  <var>range</var>, and <var>count</var> if given.
                </li>
              </ol>

              <dl class="parameters">
                <dt>optional any query</dt>
                <dd>Key or <a>IDBKeyRange</a> identifying the <a title="record">records</a> to be retrieved.
                  If null or not given, an <a>unbounded key range</a> is used.
                </dd>
                <dt>[EnforceRange] optional unsigned long count</dt>
                <dd>The maximum number of <a>record</a> values to be retrieved. If more records are in
                range than are specified, only the first <var>count</var> will be retrieved. If not specified,
                all records in range will be retrieved.</dd>
              </dl>
            </dd>

            <dt>IDBRequest getAllKeys()</dt>
            <dd>
              <aside class="note">&#9752; This method is new in this edition. &#9752;</aside>

              The <code>getAllKeys(<var>query</var>, <var>count</var>)</code> method, when invoked, must run these steps:
              <ol>
                <li>Let <var>transaction</var> be this <a>object store handle</a>'s <a title="object store handle transaction">transaction</a>.</li>

                <li>Let <var>store</var> be this <a>object store handle</a>'s <a title="handle object store">object store</a>.</li>

                <li>If <var>store</var> has been deleted,
                  <a>throw</a> an <a>InvalidStateError</a> exception.</li>

                <li>If <var>transaction</var> is not <a>active</a>,
                  <a>throw</a> a <a>TransactionInactiveError</a> exception.</li>

                <li>Let <var>range</var> be the result of running
                  the steps to <a>convert a value to a key range</a>
                  with <var>query</var>.
                  If this throws an exception, <a title="throw">rethrow</a> it.
                </li>

                <li>
                  Run the <a>steps for asynchronously executing
                  a request</a> and return the <a>IDBRequest</a> created by these steps. The steps are run with this
                  <a>object store handle</a> as <var>source</var> and the <a>steps for retrieving multiple keys from an
                    object store</a> as <var>operation</var>, using <var>store</var>,
                  <var>range</var>, and <var>count</var> if given.
                </li>
              </ol>

              <dl class="parameters">
                <dt>optional any query</dt>
                <dd>Key or <a>IDBKeyRange</a> identifying the <a title="record">records</a> to be retrieved.
                  If null or not given, an <a>unbounded key range</a> is used.
                </dd>
                <dt>[EnforceRange] optional unsigned long count</dt>
                <dd>The maximum number of <a>record</a> keys to be retrieved. If more keys are in
                range than are specified, only the first <var>count</var> will be retrieved. If not specified,
                all keys in range will be retrieved.</dd>
              </dl>
            </dd>

            <dt>IDBRequest count()</dt>
            <dd>
              The <code>count(<var>query</var>)</code> method, when invoked, must run these steps:
              <ol>
                <li>Let <var>transaction</var> be this <a>object store handle</a>'s <a title="object store handle transaction">transaction</a>.</li>

                <li>Let <var>store</var> be this <a>object store handle</a>'s <a title="handle object store">object store</a>.</li>

                <li>If <var>store</var> has been deleted,
                  <a>throw</a> an <a>InvalidStateError</a> exception.</li>

                <li>If <var>transaction</var> is not <a>active</a>,
                  <a>throw</a> a <a>TransactionInactiveError</a> exception.</li>

                <li>Let <var>range</var> be the result of running
                  the steps to <a>convert a value to a key range</a>
                  with <var>query</var>.
                  If this throws an exception, <a title="throw">rethrow</a> it.
                </li>

                <li>
                  Run the <a>steps for asynchronously executing a request</a> and return the <a>IDBRequest</a> created by these steps.
                  The steps are run with this <a>object store handle</a> as <var>source</var> and the <a>steps to count the records in a range</a> as <var>operation</var>,
                  with <var>source</var> and <var>range</var>.
                </li>
              </ol>

              <dl class="parameters">
                <dt>optional any query</dt>
                <dd>
                  The <a>key</a> or <a>IDBKeyRange</a> indicating the records to count.
                  If null or not given, an <a>unbounded key range</a> is used.
                </dd>
              </dl>
            </dd>

            <dt>IDBRequest openCursor()</dt>
            <dd>
              The <code>openCursor(<var>query</var>, <var>direction</var>)</code> method, when invoked, must run these steps:
              <ol>
                <li>Let <var>transaction</var> be this <a>object store handle</a>'s <a title="object store handle transaction">transaction</a>.</li>

                <li>Let <var>store</var> be this <a>object store handle</a>'s <a title="handle object store">object store</a>.</li>

                <li>If <var>store</var> has been deleted,
                  <a>throw</a> an <a>InvalidStateError</a> exception.</li>

                <li>If <var>transaction</var> is not <a>active</a>,
                  <a>throw</a> a <a>TransactionInactiveError</a> exception.</li>

                <li>Let <var>range</var> be the result of running
                  the steps to <a>convert a value to a key range</a>
                  with <var>query</var>.
                  If this throws an exception, <a title="throw">rethrow</a> it.
                </li>

                <li>
                  Let <var>cursor</var> be a new <a>cursor</a>
                  with <a title="cursor transaction">transaction</a> set to <var>transaction</var>,
                  an undefined <a>position</a>, <a>direction</a> set to
                  <var>direction</var>, <a>got value flag</a> unset, and undefined
                  <a title="cursor key">key</a> and <a title="cursor value">value</a>. The <a title="cursor source">source</a>
                  of <var>cursor</var> is <var>store</var>.
                  The <a>range</a> of <var>cursor</var> is <var>range</var>.
                </li>

                <li>
                  Run the <a>steps for asynchronously executing a request</a> and return the <a>IDBRequest</a>
                  created by these steps. The steps are run with this <a>object store handle</a> as <var>source</var> and the
                  <a>steps for iterating a cursor</a> with <var>cursor</var> as <var>operation</var>.
                </li>
              </ol>

              <dl class="parameters">
                <dt>optional any query</dt>
                <dd>The <a>key</a> or <a>IDBKeyRange</a> to use as the <a>cursor</a>'s <a>range</a>.
                  If null or not given, an <a>unbounded key range</a> is used.
                </dd>
                <dt>optional IDBCursorDirection direction = "next"</dt>
                <dd>The <a>cursor</a>'s required <a>direction</a></dd>
              </dl>
            </dd>
            <dt>IDBRequest openKeyCursor()</dt>
            <dd>
              <aside class="note">&#9752; This method is new in this edition. &#9752;</aside>

              The <code>openKeyCursor(<var>query</var>, <var>direction</var>)</code> method, when invoked, must run these steps:
              <ol>
                <li>Let <var>transaction</var> be this <a>object store handle</a>'s <a title="object store handle transaction">transaction</a>.</li>

                <li>Let <var>store</var> be this <a>object store handle</a>'s <a title="handle object store">object store</a>.</li>

                <li>If <var>store</var> has been deleted,
                  <a>throw</a> an <a>InvalidStateError</a> exception.</li>

                <li>If <var>transaction</var> is not <a>active</a>,
                  <a>throw</a> a <a>TransactionInactiveError</a> exception.</li>

                <li>Let <var>range</var> be the result of running
                  the steps to <a>convert a value to a key range</a>
                  with <var>query</var>.
                  If this throws an exception, <a title="throw">rethrow</a> it.
                </li>

                <li>
                  Let <var>cursor</var> be a new <a>cursor</a>
                  with <a title="cursor transaction">transaction</a> set to <var>transaction</var>,
                  an undefined <a>position</a>, <a>direction</a> set to
                  <var>direction</var>, <a>got value flag</a> unset, and undefined
                  <a title="cursor key">key</a> and <a title="cursor value">value</a>. The <a title="cursor source">source</a>
                  of <var>cursor</var> is <var>store</var>.
                  The <a>range</a> of <var>cursor</var> is <var>range</var>.
                  The <a>key only flag</a> of <var>cursor</var> is set.
                </li>

                <li>
                  Run the <a>steps for asynchronously executing a request</a> and return the <a>IDBRequest</a>
                  created by these steps. The steps are run with this <a>object store handle</a> as <var>source</var> and the
                  <a>steps for iterating a cursor</a> with <var>cursor</var> as <var>operation</var>.
                </li>
              </ol>

              <dl class="parameters">
                <dt>optional any query</dt>
                <dd>The <a>key</a> or <a>IDBKeyRange</a> to use as the <a>cursor</a>'s <a>range</a>.
                  If null or not given, an <a>unbounded key range</a> is used.
                </dd>
                <dt>optional IDBCursorDirection direction = "next"</dt>
                <dd>The <a>cursor</a>'s required <a>direction</a></dd>
              </dl>
            </dd>

            <dt>IDBIndex createIndex()</dt>
            <dd>
              <p>
                This method creates and returns a new <a>index</a> with the given name in the <a>object store</a>.
                Note that this method must only be called from within an <a>upgrade transaction</a>.
              </p>
              The <code>createIndex(<var>name</var>, <var>keyPath</var>, <var>options</var>)</code> method, when invoked, must run these steps:
              <ol>
                <li>Let <var>transaction</var> be this <a>object store handle</a>'s <a title="object store handle transaction">transaction</a>.</li>

                <li>Let <var>store</var> be this <a>object store handle</a>'s <a title="handle object store">object store</a>.</li>

                <li>If <var>transaction</var> is not an <a>upgrade transaction</a>,
                  <a>throw</a> an <a>InvalidStateError</a> exception.
                </li>

                <li>If <var>store</var> has been deleted,
                  <a>throw</a> an <a>InvalidStateError</a> exception.
                </li>

                <li>If <var>transaction</var> is not <a>active</a>,
                  <a>throw</a> a <a>TransactionInactiveError</a> exception.
                </li>

                <li>If an <a>index</a> <a title="index name">named</a> <var>name</var> already exists in <var>store</var>,
                  <a>throw</a> a <a>ConstraintError</a> exception.
                </li>

                <li>If <var>keyPath</var> is not a <a>valid key path</a>,
                  <a>throw</a> a <a>SyntaxError</a> exception.
                </li>

                <li>Let <var>unique</var> be set if <var>options</var>'s <code>unique</code> member is true, and unset otherwise.</li>

                <li>Let <var>multiEntry</var> be set if <var>options</var>'s <code>multiEntry</code> member is true, and unset otherwise.</li>

                <li>If <var>keyPath</var> is a sequence and <var>multiEntry</var> is set,
                  <a>throw</a> an <a>InvalidAccessError</a> exception.
                </li>

                <li>
                  Let <var>index</var> be a new <a>index</a> in <var>store</var>.
                  Set <var>index</var>'s <a title="index name">name</a> to <var>name</var> and <a title="index key path">key path</a> to <var>keyPath</var>.
                  If <var>unique</var> is set, set <var>index</var>'s <a>unique flag</a>.
                  If <var>multiEntry</var> is set, set <var>index</var>'s <a>multiEntry flag</a>.
                </li>

                <li>
                  Add <var>index</var> to this <a>object store handle</a>'s <a>index set</a>.
                </li>

                <li>
                  Return a new <a>index handle</a> associated with <var>index</var> and this <var>object store handle</var>.
                </li>
              </ol>

              <p>
                The index that is requested to be created can contain constraints on the data allowed in the index's
                <a>referenced</a> object store, such as requiring uniqueness of the values referenced by the
                index's keyPath. If the <a>referenced</a> object store already contains data which violates these
                constraints, this MUST NOT cause the implementation of createIndex to throw an exception or affect what it returns.
                The implementation MUST still create and return an <a>IDBIndex</a> object,
                and the implementation MUST <a>queue a task</a> to abort the <a>upgrade transaction</a>
                which was used for the createIndex call.
              </p>
              <p>
                This method synchronously modifies the
                <a href="#widl-IDBObjectStore-indexNames"><code>indexNames</code></a> property
                on the <a>IDBObjectStore</a> instance on which it was called.
                Although this method does not return an <a>IDBRequest</a> object, the index creation itself is
                processed as an asynchronous request within the <a>upgrade transaction</a>.
              </p>
              <p>
                In some implementations it is possible for the implementation to asynchronously run into problems
                creating the index after the createIndex method has returned.
                For example in implementations where metadata about the newly created index is
                queued up to be inserted into the database asynchronously,
                or where the implementation might need to ask the user for permission for quota reasons.
                Such implementations MUST still create and return an <a>IDBIndex</a> object, and
                once the implementation determines that creating the index has failed, it MUST abort the transaction
                using the <a>steps for aborting a transaction</a> using an appropriate error as <var>error</var>. For example if
                creating the <a>index</a> failed due to quota reasons, <a>QuotaExceededError</a> MUST be used as error and if the index
                can't be created due to <a>unique flag</a> constraints, <a>ConstraintError</a> MUST be used as error.
              </p>
              <aside class="example">
                  <p>
                      The asynchronous creation of indexes is observable in the following example:
                  </p>
                  <pre class="example highlight">
                      var request1 = objectStore.put({name: "betty"}, 1);
                      var request2 = objectStore.put({name: "betty"}, 2);
                      var index = objectStore.createIndex("by_name", "name", {unique: true});
                  </pre>
                  <p>
                      At the point where <code>createIndex</code> called, neither of the <a title="request">requests</a>
                      have executed. When the second request executes, a duplicate name is created. Since the index
                      creation is considered an asynchronous <a>request</a>, the index's <a title="unique flag">uniqueness</a>
                      constraint does not cause the second <a>request</a> to fail. Instead, the <a>transaction</a> will be
                      <a title="transaction abort">aborted</a> when the index is created and the constraint fails.
                  </p>
              </aside>
              <dl class="parameters">
                <dt>DOMString name</dt>
                  <dd>The <a title="index name">name</a> of a new <a>index</a></dd>
                <dt>(DOMString or sequence&lt;DOMString&gt;) keyPath</dt>
                  <dd>The <a title="index key path">key path</a> used by the new
                  <a>index</a>.</dd>
                <dt>optional IDBIndexParameters options</dt>
                  <dd>A dictionary of optional parameters to this method.
                    <code>unique</code> specifies whether the <a>index</a>'s <a>unique flag</a> is
                    set.
                    <code>multiEntry</code> specifies whether the <a>index</a>'s <a>multiEntry flag</a> is
                    set.
                  </dd>
              </dl>
            </dd>

            <dt>IDBIndex index()</dt>
            <dd>
              The <code>index(<var>name</var>)</code> method, when invoked, must run these steps:
              <ol>
                <li>Let <var>transaction</var> be this <a>object store handle</a>'s <a title="object store handle transaction">transaction</a>.</li>

                <li>Let <var>store</var> be this <a>object store handle</a>'s <a title="handle object store">object store</a>.</li>

                <li>If <var>store</var> has been deleted,
                  <a>throw</a> an <a>InvalidStateError</a> exception.
                </li>

                <li>
                  Let <var>index</var> be the <a>index</a> <a title="index name">named</a> <var>name</var> in this
                  <a>object store handle</a>'s <a>index set</a> if one exists, or <a>throw</a> a <a>NotFoundError</a> exception otherwise.
                </li>

                <li>
                  Return an <a>index handle</a> associated with <var>index</var> and this <a>object store handle</a>.

                  <aside class="note">
                    Each call to this method on the same
                    <a>IDBObjectStore</a> instance with the same name returns the same <a>IDBIndex</a> instance.
                  </aside>

                  <aside class="note">
                    The returned <a>IDBIndex</a> instance is specific to this <a>IDBObjectStore</a> instance. If this
                    method is called on a different <a>IDBObjectStore</a> instance with the same name, a different <a>IDBIndex</a> instance is
                    returned.
                  </aside>
                </li>
              </ol>

              <dl class="parameters">
                <dt>DOMString name</dt>
                <dd>The <a title="index name">name</a> of an existing <a>index</a></dd>
              </dl>
            </dd>

            <dt>void deleteIndex()</dt>
            <dd>
              <p>
                This method destroys the <a>index</a> with the given name in the <a>object store</a>.
                Note that this method must only be called from within an <a>upgrade transaction</a>.
              </p>

              The <code>deleteIndex(<var>name</var>)</code> method, when invoked, must run these steps:
              <ol>
                <li>Let <var>transaction</var> be this <a>object store handle</a>'s <a title="object store handle transaction">transaction</a>.</li>

                <li>Let <var>store</var> be this <a>object store handle</a>'s <a title="handle object store">object store</a>.</li>

                <li>If <var>transaction</var> is not an <a>upgrade transaction</a>,
                  <a>throw</a> an <a>InvalidStateError</a> exception.
                </li>

                <li>If <var>store</var> has been deleted,
                  <a>throw</a> an <a>InvalidStateError</a> exception.
                </li>

                <li>If <var>transaction</var> is not <a>active</a>,
                  <a>throw</a> a <a>TransactionInactiveError</a> exception.
                </li>

                <li>
                  Let <var>index</var> be the <a>index</a> <a title="index name">named</a> <var>name</var> in <var>store</var>
                  if one exists, or <a>throw</a> a <a>NotFoundError</a> exception otherwise.
                </li>

                <li>
                  Remove <var>index</var> from this <a>object store handle</a>'s <a>index set</a>.
                </li>

                <li>Destroy <var>index</var>.
                </li>
              </ol>

              <p>
                This method synchronously modifies the
                <a href="#widl-IDBObjectStore-indexNames"><code>indexNames</code></a> property
                on the <a>IDBObjectStore</a> instance on which it was called.
                Although this method does not return an <a>IDBRequest</a> object, the index destruction itself is
                processed as an asynchronous request within the <a>upgrade transaction</a>.
              </p>
              <dl class="parameters">
                <dt>DOMString indexName</dt>
                <dd>The <a title="index name">name</a> of an existing <a>index</a></dd>
              </dl>
            </dd>

          </dl>

          <dl class="idl" title="dictionary IDBObjectStoreParameters">
            <dt>(DOMString or sequence&lt;DOMString&gt;)? keyPath = null
            <dd>
            <dt>boolean autoIncrement = false
            <dd>
          </dl>
        </section>

        <section class="section" id="index">
          <h4>The <code>IDBIndex</code> interface</h4>
          <!-- TODO Add example. Should examples be in a separate section?-->
          <p>
            The <a>IDBIndex</a> interface represents an <a>index handle</a>.
          </p>

          <dl class="idl" title="[Exposed=(Window,Worker)] interface IDBIndex">
            <dt>attribute DOMString name</dt>
            <dd>
              <p>
                The <code>name</code> attribute's getter must return
                this <a>index handle</a>'s <a title="handle index">index</a>'s <a title="index name">name</a>.

                <aside class="note">
                  As long as the <a>transaction</a> has not <a title="transaction finish">finished</a>,
                  this is the same as the associated <a>index</a>'s <a title="index name">name</a>.

                  Once the <a>transaction</a> has <a title="transaction finish">finished</a>,
                  this attribute will not reflect changes made with a later <a>upgrade transaction</a>.
                </aside>
              </p>
              <p>
                The <code>name</code> attribute's setter must run these steps:
                <aside class="note">&#9752; This setter is new in this edition. &#9752;</aside>
              </p>
              <ol>
                <li>Let <var>name</var> be the given value.</li>

                <li>Let <var>transaction</var> be this <a>index handle</a>'s <a title="index handle transaction">transaction</a>.</li>

                <li>Let <var>index</var> be this <a>index handle</a>'s <a title="handle index">index</a>.</li>

                <li>If <var>transaction</var> is not an <a>upgrade transaction</a>,
                  <a>throw</a> an <a>InvalidStateError</a> exception.
                </li>

                <li>If <var>transaction</var> is not <a>active</a>,
                  <a>throw</a> a <a>TransactionInactiveError</a> exception.
                </li>

                <li>If <var>index</var> or <var>index</var>'s <a>object store</a> has been deleted,
                  <a>throw</a> an <a>InvalidStateError</a> exception.</li>

                <li>If <var>index</var>'s <a title="index name">name</a> is equal to <var>name</var>, terminate these steps.</li>

                <li>
                  If an <a>index</a> <a title="index name">named</a> <var>name</var> already exists in
                  <var>index</var>'s <a>object store</a>,
                  <a>throw</a> a <a>ConstraintError</a> exception.
                </li>

                <li>
                  Set <var>index</var>'s <a title="index name">name</a> to <var>name</var>.
                </li>
                <li>
                  Set this <a>index handle</a>'s <a title="index handle name">name</a> to <var>name</var>.
                </li>
              </ol>
            </dd>

            <dt>readonly attribute IDBObjectStore objectStore</dt>
            <dd>
              The <code>objectStore</code> attribute's getter
              must return this <a>index handle</a>'s
              <a title="index handle object store">object store handle</a>.
            </dd>

            <dt>readonly attribute any keyPath</dt>
            <dd>
              <p>
                The <code>keyPath</code> attribute's getter must return
                this <a>index handle</a>'s <a title="handle index">index</a>'s <a title="object store key path">key path</a>.
              </p>
              <p>
                The conversion is done following the normal [[!WEBIDL]] binding logic for
                <a>DOMString</a> and <a>sequence&lt;DOMString&gt;</a> values,
                as appropriate.
              </p>
              <p>
                The returned value is not the same instance that was used when the <a>index</a>
                was created. However, if this attribute returns an object (specifically an <code>Array</code>),
                it returns the same object instance every time it is inspected. Changing
                the properties of the object has no effect on the <a>index</a>.
              </p>
            </dd>

            <dt>readonly attribute boolean multiEntry</dt>
            <dd>
              The <code>multiEntry</code> attribute's getter must return true if this
              <a>index handle</a>'s <a title="handle index">index</a>'s
              <a>multiEntry flag</a> is set, and false otherwise.
            </dd>

            <dt>readonly attribute boolean unique</dt>
            <dd>
              The <code>unique</code> attribute's getter must return true if this
              <a>index handle</a>'s <a title="handle index">index</a>'s
              <a>unique flag</a> is set, and false otherwise.
            </dd>

            <dt>IDBRequest get()</dt>
            <dd>
              The <code>get(<var>query</var>)</code> method, when invoked, must run these steps:
              <ol>
                <li>Let <var>transaction</var> be this <a>index handle</a>'s <a title="index handle transaction">transaction</a>.</li>

                <li>Let <var>index</var> be this <a>index handle</a>'s <a title="handle index">index</a>.</li>

                <li>If <var>index</var> or <var>index</var>'s <a>object store</a> has been deleted,
                  <a>throw</a> an <a>InvalidStateError</a> exception.</li>

                <li>If <var>transaction</var> is not <a>active</a>,
                  <a>throw</a> a <a>TransactionInactiveError</a> exception.</li>

                <li>Let <var>range</var> be the result of running
                  the steps to <a>convert a value to a key range</a>
                  with <var>query</var> and <var>null disallowed flag</var> set.
                  If this throws an exception, <a title="throw">rethrow</a> it.
                </li>

                <li>
                  Run the <a>steps for asynchronously executing
                  a request</a> and return the <a>IDBRequest</a> created by these steps. The steps are run with this
                  <a>index handle</a> as <var>source</var> and the <a>steps for retrieving a referenced value from an
                    index</a> as <var>operation</var>, using <var>index</var> and
                  <var>range</var>.
                </li>
              </ol>

              <aside class="note">
                This method produces the same result if a record with the given key doesn't exist as when a record
                exists, but has undefined as value. If you need to tell the two situations apart, you can use
                <a href="#widl-IDBIndex-openCursor-IDBRequest-any-range-IDBCursorDirection-direction"><code>openCursor</code></a> with the same key. This will return a cursor with
                undefined as value if a record exists, or no cursor if no such record exists.
              </aside>

              <dl class="parameters">
                <dt>any query</dt>
                <dd>Key identifying the record to be retrieved. This can also be an <a>IDBKeyRange</a> in which case
                the method retrieves the first existing value in that range.</dd>
              </dl>
            </dd>

            <dt>IDBRequest getKey()</dt>
            <dd>
              <p>
                Gets the <a>key</a> of the <a>record</a> from the referenced <a>object store</a> entry.
              </p>

              The <code>getKey(<var>query</var>)</code> method, when invoked, must run these steps:
              <ol>
                <li>Let <var>transaction</var> be this <a>index handle</a>'s <a title="index handle transaction">transaction</a>.</li>

                <li>Let <var>index</var> be this <a>index handle</a>'s <a title="handle index">index</a>.</li>

                <li>If <var>index</var> or <var>index</var>'s <a>object store</a> has been deleted,
                  <a>throw</a> an <a>InvalidStateError</a> exception.</li>

                <li>If <var>transaction</var> is not <a>active</a>,
                  <a>throw</a> a <a>TransactionInactiveError</a> exception.</li>

                <li>Let <var>range</var> be the result of running
                  the steps to <a>convert a value to a key range</a>
                  with <var>query</var> and <var>null disallowed flag</var> set.
                  If this throws an exception, <a title="throw">rethrow</a> it.
                </li>

                <li>
                  Run the <a>steps for asynchronously executing
                  a request</a> and return the <a>IDBRequest</a> created by these steps. The steps are run with this
                  <a>index handle</a> as <var>source</var> and the <a>steps for retrieving a value from an
                    index</a> as <var>operation</var>, using <var>index</var> and
                  <var>range</var>.
                </li>
              </ol>

              <dl class="parameters">
                <dt>any query</dt>
                <dd>Key identifying the record to be retrieved. This can also be an <a>IDBKeyRange</a> in which case
                the method retrieves the first existing value in that range.</dd>
              </dl>
            </dd>

            <dt>IDBRequest getAll()</dt>
            <dd>
              <aside class="note">&#9752; This method is new in this edition. &#9752;</aside>

              The <code>getAll(<var>query</var>, <var>count</var>)</code> method, when invoked, must run these steps:
              <ol>
                <li>Let <var>transaction</var> be this <a>index handle</a>'s <a title="index handle transaction">transaction</a>.</li>

                <li>Let <var>index</var> be this <a>index handle</a>'s <a title="handle index">index</a>.</li>

                <li>If <var>index</var> or <var>index</var>'s <a>object store</a> has been deleted,
                  <a>throw</a> an <a>InvalidStateError</a> exception.</li>

                <li>If <var>transaction</var> is not <a>active</a>,
                  <a>throw</a> a <a>TransactionInactiveError</a> exception.</li>

                <li>Let <var>range</var> be the result of running
                  the steps to <a>convert a value to a key range</a>
                  with <var>query</var>.
                  If this throws an exception, <a title="throw">rethrow</a> it.
                </li>

                <li>
                  Run the <a>steps for asynchronously executing
                  a request</a> and return the <a>IDBRequest</a> created by these steps. The steps are run with this
                  <a>index handle</a> as <var>source</var> and the <a>steps for retrieving multiple referenced values from an
                    index</a> as <var>operation</var>, using <var>index</var>,
                  <var>range</var>, and <var>count</var> if given.
                </li>
              </ol>

              <dl class="parameters">
                <dt>optional any query</dt>
                <dd>Key or <a>IDBKeyRange</a> identifying the <a title="record">records</a> to be retrieved.
                  If null or not given, an <a>unbounded key range</a> is used.
                </dd>
                <dt>[EnforceRange] optional unsigned long count</dt>
                <dd>The maximum number of <a>record</a> values to be retrieved. If more records are in
                range than are specified, only the first <var>count</var> will be retrieved. If not specified,
                all records in range will be retrieved.</dd>
              </dl>
            </dd>

            <dt>IDBRequest getAllKeys()</dt>
            <dd>
              <aside class="note">&#9752; This method is new in this edition. &#9752;</aside>

              The <code>getAllKeys(<var>query</var>, <var>count</var>)</code> method, when invoked, must run these steps:
              <ol>
                <li>Let <var>transaction</var> be this <a>index handle</a>'s <a title="index handle transaction">transaction</a>.</li>

                <li>Let <var>index</var> be this <a>index handle</a>'s <a title="handle index">index</a>.</li>

                <li>If <var>index</var> or <var>index</var>'s <a>object store</a> has been deleted,
                  <a>throw</a> an <a>InvalidStateError</a> exception.</li>

                <li>If <var>transaction</var> is not <a>active</a>,
                  <a>throw</a> a <a>TransactionInactiveError</a> exception.</li>

                <li>Let <var>range</var> be the result of running
                  the steps to <a>convert a value to a key range</a>
                  with <var>query</var>.
                  If this throws an exception, <a title="throw">rethrow</a> it.
                </li>

                <li>
                  Run the <a>steps for asynchronously executing
                  a request</a> and return the <a>IDBRequest</a> created by these steps. The steps are run with this
                  <a>index handle</a> as <var>source</var> and the <a>steps for retrieving multiple values from an
                    index</a> as <var>operation</var>, using <var>index</var>,
                  <var>range</var>, and <var>count</var> if given.
                </li>
              </ol>

              <dl class="parameters">
                <dt>optional any query</dt>
                <dd>Key or <a>IDBKeyRange</a> identifying the <a title="record">records</a> to be retrieved.
                  If null or not given, an <a>unbounded key range</a> is used.
                </dd>
                <dt>[EnforceRange] optional unsigned long count</dt>
                <dd>The maximum number of <a>record</a> keys to be retrieved. If more keys are in
                range than are specified, only the first <var>count</var> will be retrieved. If not specified,
                all keys in range will be retrieved.</dd>
              </dl>
            </dd>

            <dt>IDBRequest count()</dt>
            <dd>
              The <code>count(<var>query</var>)</code> method, when invoked, must run these steps:
              <ol>
                <li>Let <var>transaction</var> be this <a>index handle</a>'s <a title="index handle transaction">transaction</a>.</li>

                <li>Let <var>index</var> be this <a>index handle</a>'s <a title="handle index">index</a>.</li>

                <li>If <var>index</var> or <var>index</var>'s <a>object store</a> has been deleted,
                  <a>throw</a> an <a>InvalidStateError</a> exception.</li>

                <li>If <var>transaction</var> is not <a>active</a>,
                  <a>throw</a> a <a>TransactionInactiveError</a> exception.</li>

                <li>Let <var>range</var> be the result of running
                  the steps to <a>convert a value to a key range</a>
                  with <var>query</var>.
                  If this throws an exception, <a title="throw">rethrow</a> it.
                </li>

                <li>
                  Run the <a>steps for asynchronously executing a request</a> and return the <a>IDBRequest</a> created by these steps.
                  The steps are run with this <a>index handle</a> as <var>source</var> and the <a>steps to count the records in a range</a> as <var>operation</var>,
                  with <a>index</a> as <var>source</var> and <var>range</var>.
                </li>
              </ol>

              <dl class="parameters">
                <dt>optional any query</dt>
                <dd>
                  <a>Key</a> or <a>IDBKeyRange</a> identifying the records to be counted.
                  If null or not given, an <a>unbounded key range</a> is used.
                </dd>
              </dl>
            </dd>

            <dt>IDBRequest openCursor()</dt>
            <dd>
              The <code>openCursor(<var>query</var>, <var>direction</var>)</code> method, when invoked, must run these steps:
              <ol>
                <li>Let <var>transaction</var> be this <a>index handle</a>'s <a title="index handle transaction">transaction</a>.</li>

                <li>Let <var>index</var> be this <a>index handle</a>'s <a title="handle index">index</a>.</li>

                <li>If <var>index</var> or <var>index</var>'s <a>object store</a> has been deleted,
                  <a>throw</a> an <a>InvalidStateError</a> exception.</li>

                <li>If <var>transaction</var> is not <a>active</a>,
                  <a>throw</a> a <a>TransactionInactiveError</a> exception.</li>

                <li>Let <var>range</var> be the result of running
                  the steps to <a>convert a value to a key range</a>
                  with <var>query</var>.
                  If this throws an exception, <a title="throw">rethrow</a> it.
                </li>

                <li>
                  Let <var>cursor</var> be a new <a>cursor</a>
                  with <a title="cursor transaction">transaction</a> set to <var>transaction</var>,
                  an undefined <a>position</a>, <a>direction</a> set to
                  <var>direction</var>, <a>got value flag</a> unset, and undefined
                  <a title="cursor key">key</a> and <a title="cursor value">value</a>. The <a title="cursor source">source</a>
                  of <var>cursor</var> is <var>index</var>.
                  The <a>range</a> of <var>cursor</var> is <var>range</var>.
                </li>

                <li>
                  Run the <a>steps for asynchronously executing a request</a> and return the <a>IDBRequest</a>
                  created by these steps. The steps are run with this <a>index handle</a> as <var>source</var> and the
                  <a>steps for iterating a cursor</a> with <var>cursor</var> as <var>operation</var>.
                </li>
              </ol>

              <dl class="parameters">
                <dt>optional any query</dt>
                <dd>The <a>key</a> or <a>IDBKeyRange</a> to use as the <a>cursor</a>'s <a>range</a>.
                  If null or not given, all records are counted.
                </dd>
                <dt>optional IDBCursorDirection direction = "next"</dt>
                <dd>The <a>cursor</a>'s required <a>direction</a></dd>
              </dl>
            </dd>
            <dt>IDBRequest openKeyCursor()</dt>
            <dd>
              The <code>openKeyCursor(<var>query</var>, <var>direction</var>)</code> method, when invoked, must run these steps:
              <ol>
                <li>Let <var>transaction</var> be this <a>index handle</a>'s <a title="index handle transaction">transaction</a>.</li>

                <li>Let <var>index</var> be this <a>index handle</a>'s <a title="handle index">index</a>.</li>

                <li>If <var>index</var> or <var>index</var>'s <a>object store</a> has been deleted,
                  <a>throw</a> an <a>InvalidStateError</a> exception.</li>

                <li>If <var>transaction</var> is not <a>active</a>,
                  <a>throw</a> a <a>TransactionInactiveError</a> exception.</li>

                <li>Let <var>range</var> be the result of running
                  the steps to <a>convert a value to a key range</a>
                  with <var>query</var>.
                  If this throws an exception, <a title="throw">rethrow</a> it.
                </li>

                <li>
                  Let <var>cursor</var> be a new <a>cursor</a>
                  with <a title="cursor transaction">transaction</a> set to <var>transaction</var>,
                  an undefined <a>position</a>, <a>direction</a> set to
                  <var>direction</var>, <a>got value flag</a> unset, and undefined
                  <a title="cursor key">key</a> and <a title="cursor value">value</a>. The <a title="cursor source">source</a>
                  of <var>cursor</var> is <var>index</index>.
                  The <a>range</a> of <var>cursor</var> is <var>range</var>.
                  The <a>key only flag</a> of <var>cursor</var> is set.
                </li>

                <li>
                  Run the <a>steps for asynchronously executing a request</a> and return the <a>IDBRequest</a>
                  created by these steps. The steps are run with this <a>index handle</a> as <var>source</var> and the
                  <a>steps for iterating a cursor</a> with <var>cursor</var> as <var>operation</var>.
                </li>
              </ol>

              <dl class="parameters">
                <dt>optional any query</dt>
                <dd>The <a>key</a> or <a>IDBKeyRange</a> to use as the <a>cursor</a>'s <a>range</a>.
                  If null or not given, all records are counted.
                </dd>
                <dt>optional IDBCursorDirection direction = "next"</dt>
                <dd>The <a>cursor</a>'s required <a>direction</a></dd>
              </dl>
            </dd>

          </dl>

          <dl class="idl" title="dictionary IDBIndexParameters">
            <dt>boolean unique = false
            <dd>
            <dt>boolean multiEntry = false
            <dd>
          </dl>
        </section>

        <section class="section" id="keyrange">
          <h4>The <code>IDBKeyRange</code> interface</h4>
          <p>
            The <a>IDBKeyRange</a> interface represents a
            <a>key range</a>.
          </p>
          <dl class="idl" title="[Exposed=(Window,Worker)] interface IDBKeyRange">
            <dt>readonly attribute any lower</dt>
            <dd>
              The <code>lower</code> attribute's getter must return
              result of running the steps to <a>convert a key to a value</a>
              with the <a>lower bound</a> if it is not null, or undefined otherwise.</dd>

            <dt>readonly attribute any upper</dt>
            <dd>
              The <code>upper</code> attribute's getter must return
              the result of running the steps to <a>convert a key to a value</a>
              with the <a>upper bound</a> if it is not null, or undefined otherwise.</dd>

            <dt>readonly attribute boolean lowerOpen</dt>
            <dd>
              The <code>lowerOpen</code> attribute's getter must return
              true if the <a>lower open flag</a> is set, and false otherwise.</dd>

            <dt>readonly attribute boolean upperOpen</dt>
            <dd>
              The <code>upperOpen</code> attribute's getter must return
              true if the <a>upper open flag</a> is set, and false otherwise.</dd>

            <dt>static IDBKeyRange only()</dt>
            <dd>
              The <code>only(<var>value</var>)</code> method, when invoked, must run these steps:
              <ol>
                <li>Let <var>key</var> be the result of running the steps to <a>convert a value to a key</a> with <var>value</var>.
                  If this throws an an exception, <a title="throw">rethrow</a> it.</li>
                <li>If <var>key</var> is invalid, <a>throw</a> a <a>DataError</a> exception.</li>

                <li>Create and return a new <a>key range</a> <a>containing only</a> <var>key</var>.</li>
              </ol>

              <dl class="parameters">
                <dt>any value</dt>
                <dd>The only value</dd>
              </dl>
            </dd>

            <dt>static IDBKeyRange lowerBound()</dt>
            <dd>
              The <code>lowerBound(<var>lower</var>, <var>lowerOpen</var>)</code> method, when invoked, must run these steps:
              <ol>
                <li>Let <var>lowerKey</var> be the result of running the steps to <a>convert a value to a key</a> with <var>lower</var>.
                  If this throws an an exception, <a title="throw">rethrow</a> it.</li>
                <li>If <var>lowerKey</var> is invalid, <a>throw</a> a <a>DataError</a> exception.</li>

                <li>Create and return a new <a>key range</a> with
                  <a>lower bound</a> set to <var>lowerKey</var>,
                  <a>lower open flag</a> set if <var>lowerOpen</var> is true,
                  <a>upper bound</a> set to null and
                  <a>upper open flag</a> set.
                </li>
              </ol>

              <dl class="parameters">
                <dt>any lower</dt>
                <dd>The lower bound value</dd>
                <dt>optional boolean open = false</dt>
                <dd>Specify false if the lower-bound should be included in the <a>key range</a>. Specify true if the lower-bound value should
                be excluded from the <a>key range</a>. Defaults to false (lower-bound value is included).</dd>
              </dl>
            </dd>

            <dt>static IDBKeyRange upperBound()</dt>
            <dd>
              The <code>upperBound(<var>upper</var>, <var>upperOpen</var>)</code> method, when invoked, must run these steps:
              <ol>
                <li>Let <var>upperKey</var> be the result of running the steps to <a>convert a value to a key</a> with <var>upper</var>.
                  If this throws an an exception, <a title="throw">rethrow</a> it.</li>
                <li>If <var>upperKey</var> is invalid, <a>throw</a> a <a>DataError</a> exception.</li>

                <li>Create and return a new <a>key range</a> with
                  <a>lower bound</a> set to null,
                  <a>lower open flag</a> set,
                  <a>upper bound</a> set if <var>upperKey</var>, and
                  <a>upper open flag</a> set to <var>upperOpen</var>.
                </li>
              </ol>

              <dl class="parameters">
                <dt>any upper</dt>
                <dd>The upper bound value</dd>
                <dt>optional boolean open = false</dt>
                <dd>Specify false if the upper-bound should be included in the <a>key range</a>. Specify true if the upper-bound value should
                be excluded from the <a>key range</a>. Defaults to false (upper-bound value is included).</dd>
              </dl>
            </dd>

            <dt>static IDBKeyRange bound()</dt>
            <dd>
              The <code>bound(<var>lower</var>, <var>upper</var>, <var>lowerOpen</var>, <var>upperOpen</var>)</code> method, when invoked, must run these steps:
              <ol>
                <li>Let <var>lowerKey</var> be the result of running the steps to <a>convert a value to a key</a> with <var>lower</var>.
                  If this throws an an exception, <a title="throw">rethrow</a> it.</li>
                <li>If <var>lowerKey</var> is invalid, <a>throw</a> a <a>DataError</a> exception.</li>

                <li>Let <var>upperKey</var> be the result of running the steps to <a>convert a value to a key</a> with <var>upper</var>.
                  If this throws an an exception, <a title="throw">rethrow</a> it.</li>
                <li>If <var>upperKey</var> is invalid, <a>throw</a> a <a>DataError</a> exception.</li>

                <li>If <var>lowerKey</var> is <a>greater than</a> <var>upperKey</var>, <a>throw</a> a <a>DataError</a> exception.</li>

                <li>Create and return a new <a>key range</a> with
                  <a>lower bound</a> set to <var>lowerKey</var>,
                  <a>lower open flag</a> set if <var>lowerOpen</var> is true,
                  <a>upper bound</a> set to <var>upperKey</var> and
                  <a>upper open flag</a> set if <var>upperOpen</var> is true.
                </li>
              </ol>
              <dl class="parameters">
                <dt>any lower</dt>
                <dd>The lower-bound value</dd>
                <dt>any upper</dt>
                <dd>The upper-bound value</dd>
                <dt>optional boolean lowerOpen = false</dt>
                <dd>Specify false if the lower-bound should be included in the <a>key range</a>. Specify true if the lower-bound value should
                be excluded from the <a>key range</a>. Defaults to false (lower-bound value is included).</dd>
                <dt>optional boolean upperOpen = false</dt>
                <dd>Specify false if the upper-bound should be included in the <a>key range</a>. Specify true if the upper-bound value should
                be excluded from the <a>key range</a>. Defaults to false (upper-bound value is included).</dd>
              </dl>
            </dd>
          </dl>
        </section>

        <section class="section" id="cursor">
          <h4>The <code>IDBCursor</code> interface</h4>
          <!-- TODO Add example. Should examples be in a separate section?-->
          <p>
            <a>Cursor</a> objects implement the <a>IDBCursor</a> interface. There is only ever one
            <a>IDBCursor</a> instance representing a given <a>cursor</a>.
            There is no limit on how many cursors can be used at the same time.
          </p>

          <dl class="idl" title="[Exposed=(Window,Worker)] interface IDBCursor">
            <dt>readonly attribute (IDBObjectStore or IDBIndex) source</dt>
            <dd>
              The <code>source</code> attribute's getter must return the <a title="cursor source">source</a> of this <a>cursor</a>.
              This attribute
              never returns null or throws an exception, even if the cursor is currently being iterated, has iterated past its end,
              or its <a>transaction</a> is not <a>active</a>.
            </dd>

            <dt>readonly attribute IDBCursorDirection direction</dt>
            <dd>
              The <code>direction</code> attribute's getter must return the
              <a>direction</a> of the <a>cursor</a>.
            </dd>

            <dt>readonly attribute any key</dt>
            <dd>
              The <code>key</code> attribute's getter must return
              the result of running the steps to <a>convert a key to a value</a>
              with the cursor's current <a title="cursor key">key</a>.
            Note that if this property returns an object (e.g. a <code>Date</code> or <code>Array</code>), it returns the same
            object instance every time it is inspected, until the cursor's <a title="cursor key">key</a> is changed.
            This means that if the object is modified,
            those modifications will be seen by anyone inspecting the value of the cursor. However modifying such an object
            does not modify the contents of the database.</dd>

            <dt>readonly attribute any primaryKey</dt>
            <dd>
              The <code>primaryKey</code> attribute's getter must return
              the result of running the steps to <a>convert a key to a value</a>
              with the cursor's current <a>effective key</a>.
            Note that if this property returns an object (e.g. a <code>Date</code> or <code>Array</code>), it returns the same
            object instance every time it is inspected, until the cursor's <a>effective key</a> is changed.
            This means that if the object is modified,
            those modifications will be seen by anyone inspecting the value of the cursor. However modifying such an object
            does not modify the contents of the database.</dd>

            <dt>IDBRequest update()</dt>
            <dd>
              The <code>update(<var>value</var>)</code> method, when invoked, must run these steps:
              <ol>
                <li>Let <var>transaction</var> be this <a>cursor</a>'s <a title="cursor transaction">transaction</a>.</li>

                <li>If <var>transaction</var> is not <a>active</a>,
                  <a>throw</a> a <a>TransactionInactiveError</a> exception.</li>

                <li>If <var>transaction</var> is a <a>read-only transaction</a>,
                  <a>throw</a> a <a>ReadOnlyError</a> exception.</li>

                <li>If the cursor's <a title="cursor source">source</a> or <a>effective object store</a> has been deleted,
                  <a>throw</a> an <a>InvalidStateError</a> exception.</li>

                <li>If this cursor's <a>got value flag</a> is unset, indicating that the cursor is being iterated or has iterated past its end,
                  <a>throw</a> an <a>InvalidStateError</a> exception.</li>

                <li>If this cursor's <a>key only flag</a> is set,
                  <a>throw</a> an <a>InvalidStateError</a> exception.</li>

                <li>Let <var>clone</var> be <a>structured clone</a> of <var>value</var>. If this
                  throws an exception, <a title="throw">rethrow</a> the exception.</li>

                <li>If the <a>effective object store</a> of this cursor uses <a>in-line keys</a>
                  <ol>
                    <li>Let <var>kpk</var> be the result of running the steps to <a>extract a key from a value using a key path</a>
                      with <var>clone</var> and the <a title="object store key path">key path</a> of the <a>effective object store</a>.
                      If this throws an exception, <a title="throw">rethrow</a> it.</li>
                    <li>If <var>kpk</var> is failure, invalid, or not <a>equal to</a> the cursor's <a>effective key</a>,
                      <a>throw</a> a <a>DataError</a> exception.</li>
                  </ol>
                </li>

                <li>Run <a>steps for asynchronously executing a request</a> and
                  return the <a>IDBRequest</a> created by these steps.
                  The steps are run with this <a>cursor</a> as <var>source</var> and the <a>steps for
                  storing a record into an object store</a> as <var>operation</var>, using this cursor's
                  <a>effective object store</a> as <var>store</var>, the <var>clone</var> as <var>value</var>,
                  this cursor's <a>effective key</a> as <var>key</var>, and with the <var>no-overwrite flag</var>
                  unset.
                </li>
              </ol>

              <aside class="note">
                A result of running the <a>steps for storing a record into an object store</a> is that if the record
                has been deleted since the cursor moved to it, a new record will be created.
              </aside>

              <dl class="parameters">
                <dt>any value</dt>
                <dd>The new value to store at the current position.</dd>
              </dl>
            </dd>

            <dt>void advance()</dt>
            <dd>
              The <code>advance(<var>count</var>)</code> method, when invoked, must run these steps:
              <ol>
                <li>If <var>count</var> is 0 (zero),
                  <a>throw</a> a <code>TypeError</code>.

                <li>Let <var>transaction</var> be this <a>cursor</a>'s <a title="cursor transaction">transaction</a>.</li>

                <li>If <var>transaction</var> is not <a>active</a>,
                  <a>throw</a> a <a>TransactionInactiveError</a> exception.</li>

                <li>If the cursor's <a title="cursor source">source</a> or <a>effective object store</a> has been deleted,
                  <a>throw</a> an <a>InvalidStateError</a> exception.</li>

                <li>If this cursor's <a>got value flag</a> is unset, indicating that the cursor is being iterated or has iterated past its end,
                  <a>throw</a> an <a>InvalidStateError</a> exception.</li>

                <li>Unset the <a>got value flag</a> on the cursor.</li>

                <li>
                  Let <var>request</var> be the <a>request</a> created when this <a>cursor</a> was created.
                </li>

                <li>Unset the <a title="request done">done flag</a> on <var>request</var>.</li>

                <li>
                  Run the <a>steps for asynchronously executing a request</a>
                  with the cursor's
                  <a title="cursor source">source</a> as <var>source</var> and the
                  <a>steps for iterating a cursor</a> with this <a>cursor</a> and <var>count</var>,
                  and <var>request</var>.
                </li>
              </ol>

              <aside class="note">
                Calling this method more than once before new cursor data has been loaded - for example,
                calling <code>advance()</code> twice from the same onsuccess handler -
                results in an <a>InvalidStateError</a> exception being thrown on the second call
                because the cursor's <a>got value flag</a> has been unset.
              </aside>

              <dl class="parameters">
                <dt>[EnforceRange] unsigned long count</dt>
                <dd>The number of advances forward the cursor should make.</dd>
              </dl>
            </dd>

            <dt>void continue()</dt>
            <dd>
              The <code>continue(<var>key</var>)</code> method, when invoked, must run these steps:
              <ol>
                <li>Let <var>transaction</var> be this <a>cursor</a>'s <a title="cursor transaction">transaction</a>.</li>

                <li>If <var>transaction</var> is not <a>active</a>,
                  <a>throw</a> a <a>TransactionInactiveError</a> exception.</li>

                <li>If the cursor's <a title="cursor source">source</a> or <a>effective object store</a> has been deleted,
                  <a>throw</a> an <a>InvalidStateError</a> exception.</li>

                <li>If this cursor's <a>got value flag</a> is unset, indicating that the cursor is being iterated or has iterated past its end,
                  <a>throw</a> an <a>InvalidStateError</a> exception.</li>

                <li>If <var>key</var> is given:
                  <ol>
                    <li>Let <var>r</var> be the result of running the steps to <a>convert a value to a key</a> with <var>key</var>.
                      If this throws an exception, <a title="throw">rethrow</a> it.</li>
                    <li>If <var>r</var> is invalid, <a>throw</a> a <a>DataError</a> exception.</li>
                    <li>Let <var>key</var> be <var>r</var>.</li>

                    <li>If <var>key</var> is <a>less than</a> or <a>equal to</a> this cursor's <a>position</a>
                      and this cursor's <a>direction</a> is "<code>next</code>" or "<code>nextunique</code>",
                      <a>throw</a> a <a>DataError</a> exception.</li>

                    <li>If <var>key</var> is <a>greater than</a> or <a>equal to</a> this cursor's <a>position</a>
                      and this cursor's <a>direction</a> is "<code>prev</code>" or "<code>prevunique</code>",
                      <a>throw</a> a <a>DataError</a> exception.</li>
                  </ol>
                </li>

                <li>Unset the <a>got value flag</a> on the cursor.</li>

                <li>
                  Let <var>request</var> be the <a>request</a> created when this <a>cursor</a> was created.
                </li>

                <li>Unset the <a title="request done">done flag</a> on <var>request</var>.</li>

                <li>
                  Run the <a>steps for asynchronously executing a request</a>
                  with the cursor's
                  <a title="cursor source">source</a> as <var>source</var> and
                  the <a>steps for iterating a cursor</a> with this <a>cursor</a> and <var>key</var> (if given),
                  and <var>request</var>.
                </li>
              </ol>

              <aside class="note">
                Calling this method more than once before new cursor data has been loaded -
                for example, calling <code>continue()</code> twice from the same onsuccess handler -
                results in an <a>InvalidStateError</a> exception being thrown on the second call
                because the cursor's <a>got value flag</a> has been unset.
              </aside>

              <dl class="parameters">
                <dt>optional any key</dt>
                <dd>The next key to position this <a>cursor</a> at</dd>
              </dl>
            </dd>

            <dt>void continuePrimaryKey()</dt>
            <dd>
              <aside class="note">&#9752; This method is new in this edition. &#9752;</aside>

              The <code>continuePrimaryKey(<var>key</var>, <var>primaryKey</var>)</code> method, when invoked, must run these steps:
              <ol>
                <li>Let <var>transaction</var> be this <a>cursor</a>'s <a title="cursor transaction">transaction</a>.</li>

                <li>If <var>transaction</var> is not <a>active</a>,
                  <a>throw</a> a <a>TransactionInactiveError</a> exception.</li>

                <li>If the cursor's <a title="cursor source">source</a> or <a>effective object store</a> has been deleted,
                  <a>throw</a> an <a>InvalidStateError</a> exception.</li>

                <li>If this cursor's <a title="cursor source">source</a> is not an <a>index</a>
                  <a>throw</a> an <a>InvalidAccessError</a> exception.</li>

                <li>If this cursor's <a>direction</a> is not
                  "<code>next</code>" or "<code>prev</code>",
                  <a>throw</a> an <a>InvalidAccessError</a> exception.</li>

                <li>If this cursor's <a>got value flag</a> is unset, indicating that the cursor is being iterated or has iterated past its end,
                  <a>throw</a> an <a>InvalidStateError</a> exception.</li>

                <li>Let <var>r</var> be the result of running the steps to <a>convert a value to a key</a> with <var>key</var>.
                  If this throws an exception, <a title="throw">rethrow</a> it.</li>
                <li>If <var>r</var> is invalid, <a>throw</a> a <a>DataError</a> exception.</li>
                <li>Let <var>key</var> be <var>r</var>.</li>

                <li>Let <var>r</var> be the result of running the steps to <a>convert a value to a key</a> with <var>primaryKey</var>.
                  If this throws an exception, <a title="throw">rethrow</a> it.</li>
                <li>If <var>r</var> is invalid, <a>throw</a> a <a>DataError</a> exception.</li>
                <li>Let <var>primaryKey</var> be <var>r</var>.</li>

                <li>If <var>key</var> is <a>less than</a> or <a>equal to</a> this cursor's <a>position</a>
                  and this cursor's <a>direction</a> is "<code>next</code>" or "<code>nextunique</code>",
                  <a>throw</a> a <a>DataError</a> exception.</li>

                <li>If <var>key</var> is <a>greater than</a> or <a>equal to</a> this cursor's <a>position</a>
                  and this cursor's <a>direction</a> is "<code>prev</code>" or "<code>prevunique</code>",
                  <a>throw</a> a <a>DataError</a> exception.</li>

                <li>If <var>key</var> is <a>equal to</a> this cursor's <a>position</a>
                  and <var>primaryKey</var> is <a>less than</a> or <a>equal to</a> this cursor's <a>object store position</a>
                  and this cursor's <a>direction</a> is "<code>next</code>" or "<code>nextunique</code>",
                  <a>throw</a> a <a>DataError</a> exception.</li>

                <li>If <var>key</var> is <a>equal to</a> this cursor's <a>position</a>
                  and <var>primaryKey</var> is <a>greater than</a> or <a>equal to</a> this cursor's <a>object store position</a>
                  and this cursor's <a>direction</a> is "<code>prev</code>" or "<code>prevunique</code>",
                  <a>throw</a> a <a>DataError</a> exception.</li>

                <li>Unset the <a>got value flag</a> on the cursor.</li>

                <li>
                  Let <var>request</var> be the <a>request</a> created when this <a>cursor</a> was created.
                </li>

                <li>Unset the <a title="request done">done flag</a> on <var>request</var>.</li>

                <li>
                  Run the <a>steps for asynchronously executing a request</a>
                  with the cursor's
                  <a title="cursor source">source</a> as <var>source</var> and
                  the <a>steps for iterating a cursor</a> with this <a>cursor</a>, <var>key</var>,
                  <var>primaryKey</var>, and <var>request</var>.
                </li>
              </ol>

              <aside class="note">
                Calling this method more than once before new cursor data has been loaded -
                for example, calling <code>continuePrimaryKey()</code> twice from the same onsuccess handler -
                results in an <a>InvalidStateError</a> exception being thrown on the second call
                because the cursor's <a>got value flag</a> has been unset.
              </aside>

              <dl class="parameters">
                <dt>any key</dt>
                <dd>The next key to position this <a>cursor</a> at</dd>
                <dt>any primaryKey</dt>
                <dd>The next primary key to position this <a>cursor</a> at</dd>
              </dl>
            </dd>

            <dt>IDBRequest delete()</dt>
            <dd>
              The <code>delete()</code> method, when invoked, must run these steps:
              <ol>
                <li>Let <var>transaction</var> be this <a>cursor</a>'s <a title="cursor transaction">transaction</a>.</li>

                <li>If <var>transaction</var> is not <a>active</a>,
                  <a>throw</a> a <a>TransactionInactiveError</a> exception.</li>

                <li>If <var>transaction</var> is a <a>read-only transaction</a>,
                  <a>throw</a> a <a>ReadOnlyError</a> exception.</li>

                <li>If the cursor's <a title="cursor source">source</a> or <a>effective object store</a> has been deleted,
                  <a>throw</a> an <a>InvalidStateError</a> exception.</li>

                <li>If this cursor's <a>got value flag</a> is unset, indicating that the cursor is being iterated or has iterated past its end,
                  <a>throw</a> an <a>InvalidStateError</a> exception.</li>

                <li>If this cursor's <a>key only flag</a> is set,
                  <a>throw</a> an <a>InvalidStateError</a> exception.</li>

                <li>
                  Run the <a>steps for asynchronously executing a request</a> and return the
                  <a>IDBRequest</a> created by these steps. The steps are run with this <a>cursor</a> as <var>source</var>
                  and the <a>steps for deleting records from an object store</a> as <var>operation</var>, using this cursor's
                  <a>effective object store</a> and <a>effective key</a> as <var>store</var> and <var>key</var> respectively.
                </li>
              </ol>
            </dd>
          </dl>

          <p>
            A <a>cursor</a> that has the <a>key only flag</a> unset implements the <a>IDBCursorWithValue</a> interface as well.
          </p>

          <dl class="idl" title="[Exposed=(Window,Worker)] interface IDBCursorWithValue : IDBCursor">
            <dt>readonly attribute any value</dt>
            <dd>
              The <code>value</code> attribute's getter must return
              the cursor's current <a title="cursor value">value</a>.

            Note that if this property returns an object, it returns the same
            object instance every time it is inspected, until the cursor's <a title="cursor value">value</a> is changed.
            This means that if the object is modified,
            those modifications will be seen by anyone inspecting the value of the cursor. However modifying such an object
            does not modify the contents of the database.</dd>
          </dl>

          <p>
            The <a>direction</a> of an <a>IDBCursor</a> is represented by the <a>IDBCursorDirection</a> enumeration:
          </p>

          <dl class="idl" title="enum IDBCursorDirection">
            <dt>next</dt>
            <dd>The <a>direction</a> of the <a>cursor</a> is "<code>next</code>"</dd>

            <dt>nextunique</dt>
            <dd>The <a>direction</a> of the <a>cursor</a> is "<code>nextunique</code>"</dd>

            <dt>prev</dt>
            <dd>The <a>direction</a> of the <a>cursor</a> is "<code>prev</code>"</dd>

            <dt>prevunique</dt>
            <dd>The <a>direction</a> of the <a>cursor</a> is "<code>prevunique</code>"</dd>
          </dl>

        </section>

        <section class="section" id="transaction">
          <h4>The <code>IDBTransaction</code> interface</h4>
          <!-- TODO Add example. Should examples be in a separate section?-->
          <p>
            <a title="transaction">Transaction</a> objects implement the following interface:
          </p>
          <dl class="idl" title="[Exposed=(Window,Worker)] interface IDBTransaction : EventTarget">

            <dt>readonly attribute DOMStringList objectStoreNames</dt>
            <dd>
              <aside class="note">&#9752; This attribute is new in this edition. &#9752;</aside>

              The <code>objectStoreNames</code> attribute's getter must run the following steps:
              <ol>
                <li>
                  If this <a>transaction</a> is an <a>upgrade transaction</a>, return a
                  <a>sorted list</a> of the <a title="object store name">names</a>
                  of the <a title="object store">object stores</a> in this <a>transaction</a>'s
                  <a>connection</a>'s <a>object store set</a>.
                </li>
                <li>
                  Otherwise, return a <a>sorted list</a> of the <a title="object store name">names</a>
                  of the <a title="object store">object stores</a> in this <a>transaction</a>'s <a>scope</a>.
                </li>
              </ol>

              <aside class="note">
                The contents of each list returned by this attribute does not change,
                but subsequent calls to this attribute during an <a>upgrade transaction</a>
                may return lists with different contents as <a title="object store">object stores</a>
                are created and deleted.
              </aside>
            </dd>

            <dt>readonly attribute IDBTransactionMode mode</dt>
            <dd>
              The <code>mode</code> attribute's getter must return the <a>mode</a> of the <a>transaction</a>.
            </dd>

            <dt>readonly attribute IDBDatabase db</dt>
            <dd>
              The <code>db</code> attribute's getter must return the
              <a>database</a> <a>connection</a> of which this <a>transaction</a>
              is a part.
            </dd>

            <dt>readonly attribute DOMException error</dt>
            <dd>
              The <code>error</code> attribute's getter must return this <a>transaction</a>'s <a title="transaction error">error</a>, or null if none.

              <aside class="note">
                If this <a>transaction</a> was aborted due to a failed <a>request</a>,
                this will be the same as the <a>request</a>'s <a title="request error">error</a>.

                If this <a>transaction</a> was aborted due to an uncaught exception in a event
                handler, the error will be <a>AbortError</a>.

                If the <a>transaction</a> was aborted due to an error while committing,
                it will reflect the reason for the failure (e.g. <a>QuotaExceededError</a>,
                <a>ConstraintError</a>, or <a>UnknownError</a>).
              </aside>
            </dd>

            <dt>IDBObjectStore objectStore()</dt>
            <dd>
              The <code>objectStore(<var>name</var>)</code> method, when invoked, must run these steps:
              <ol>
                <li>If <var>transaction</var> has <a title="transaction finish">finished</a>,
                  <a>throw</a> an <a>InvalidStateError</a> exception.</li>

                <li>Let <var>store</var> be the <a>object store</a> <a title="object store name">named</a> <var>name</var> in this <a>transaction</a>'s <a>scope</a>,
                  or <a>throw</a> a <a>NotFoundError</a> exception if none.
                </li>

                <li>Return an <a>object store handle</a> associated with <var>store</var> and this <a>transaction</a>.

                  <aside class="note">
                    Each call to this method on the same <a>IDBTransaction</a> instance with the same
                    name returns the same <a>IDBObjectStore</a> instance.
                  </aside>

                  <aside class="note">
                    The returned <a>IDBObjectStore</a> instance is specific to this <a>IDBTransaction</a>. If this
                    method is called on a different <a>IDBTransaction</a>, a different <a>IDBObjectStore</a> instance is returned.
                  </aside>
                </li>
              </ol>

              <dl class="parameters">
                <dt>DOMString name</dt>
                <dd>The requested <a>object store</a></dd>
              </dl>
            </dd>

            <dt>void abort()</dt>
            <dd>
              The <code>abort()</code> method, when invoked, must run these steps:
              <ol>
                <li>If this <a>transaction</a> is <a title="transaction finish">finished</a>,
                  <a>throw</a> an <a>InvalidStateError</a> exception.
                </li>
                <li>Unset the <a>transaction</a>'s <a>active flag</a> and run the
                  <a>steps for aborting a transaction</a> with null as <var>error</var>.
                </li>
              </ol>
            </dd>

            <dt>attribute EventHandler onabort</dt>
            <dd>The event handler for the <code>abort</code> event.</dd>
            <dt>attribute EventHandler oncomplete</dt>
            <dd>The event handler for the <code>complete</code> event.
            <aside class="note">
            	To determine if a <a>transaction</a> has completed successfully,
            	listen to the <a title="transaction">transaction’s</a> <code>complete</code> event rather than the <code>success</code> event of a particular <a>request</a>,
            	because the <a>transaction</a> may still fail after the <code>success</code> event fires.
            </aside>
            </dd>
            <dt>attribute EventHandler onerror</dt>
            <dd>The event handler for the <code>error</code> event.</dd>
          </dl>

          <p>
            The <a>mode</a> of an <a>IDBTransaction</a> is represented by the <a>IDBTransactionMode</a> enumeration:
          </p>

          <dl class="idl" title="enum IDBTransactionMode">
            <dt>readonly</dt>
            <dd>A <a>read-only transaction</a>.</dd>
            <dt>readwrite</dt>
            <dd>A <a>read/write transaction</a>.</dd>
            <dt>versionchange</dt>
            <dd>An <a>upgrade transaction</a>.</dd>
          </dl>



        </section>
      </section>

      <section class="section" id="algorithms">
        <h3>Algorithms</h3>

        <section class="section" id="opening">
          <h4>Opening a database</h4>
          <p>
            The <dfn>steps for opening a database</dfn> are defined in the following steps. The algorithm in these steps
            takes four arguments:
            the <var>origin</var> which requested the <a>database</a> to be opened,
            a database <var>name</var>,
            a database <var>version</var>,
            and a <var>request</var>.
          </p>

          <ol>
            <li>
              Let <var>db</var> be the <a>database</a> <a title="database name">named</a> <var>name</var> in the
              origin <var>origin</var>, or null otherwise.
            </li>
            <li>
              If <var>db</var> is not null:
              <ol>
                <li>Wait until the following conditions are all fulfilled:
                  <ul>
                    <li>
                      No already existing <a title="connection">connections</a> to <var>db</var>, have
                      non-<a title="transaction finish">finished</a> <a>upgrade transaction</a>.
                    </li>
                    <li>
                      If <var>db</var> has its <a>delete pending flag</a> set, wait until <var>db</var> has
                      been deleted.
                    </li>
                  </ul>
                  <aside class="note">
                    If several requests with the same <var>origin</var> and <var>name</var> are waiting due to the above conditions,
                    and those connections have a higher version than the database's current version, then once any of
                    those connections can proceed to the next step in this algorithm it will immediately start
                    an <a>upgrade transaction</a>. This prevents the other connections from proceeding until that
                    <a>upgrade transaction</a> is finished.
                  </aside>
                </li>
                <li>
                  If <var>db</var> was deleted, let <var>db</var> be null.
                </li>
              </ol>
            </li>
            <li>
              If <var>version</var> is undefined,
              let <var>version</var> be 1 if <var>db</var> is null, or <var>db</var>'s <a>version</a> otherwise.
            </li>
            <li>
              If <var>db</var> is null, let <var>db</var> be a new <a>database</a> with
              <a title="database name">name</a> <var>name</var>, <a>version</a> 0 (zero) as <a>version</a>,
              and with no <a title="object store">object stores</a>.
            </li>
            <li>
              If <var>db</var>'s <a>version</a> is greater than <var>version</var>, abort these steps and return
              a new <a>VersionError</a>.
            </li>
            <li>
              Let <var>connection</var> be a new <a>connection</a> to <var>db</var>.
            </li>
            <li>
              Set <var>connection</var>'s <a title="connection version">version</a> to <var>version</var>.
            </li>
            <li>
              If <var>db</var>'s <a>version</a> is less than <var>version</var>:
              <ol>
                <li>
                  Run the <a>steps for running an upgrade transaction</a>
                  using <var>connection</var>, <var>version</var> and <var>request</var>.
                </li>
                <li>
                  If <var>connection</var> was <a title="database close">closed</a>,
                  create and return a new <a>AbortError</a> exception and abort these steps.
                </li>
                <li>
                  If the <a>upgrade transaction</a> was aborted,
                  run the <a>steps for closing a database connection</a> with <var>connection</var>,
                  create and return a new <a>AbortError</a> exception and abort these steps.
                </li>
              </ol>
            </li>
            <li>
              Return <var>connection</var>.
            </li>
          </ol>
        </section>

        <section class="section">
          <h4>Closing a database</h4>
          <p>The <dfn>steps for closing a database connection</dfn> are as follows.
            These steps take two arguments, a <var>connection</var> object, and an
            optional <var>forced flag</var>.
          <ol>
            <li>
              Set the <a>close pending flag</a> of <var>connection</var>.
            </li>
            <li>
              If the <var>forced flag</var> is set, then for each <var>transaction</var> <a title="transaction create">created</a>
              using <var>connection</var> run the <a>steps for aborting a transaction</a> with
              <var>transaction</var> and newly created <a>AbortError</a> exception.
            </li>
            <li>
              Wait for all transactions <a title="transaction create">created</a> using <var>connection</var> to complete.
              Once they are complete, <var>connection</var> is <a title="database close">closed</a>.
            </li>
            <li>
              If the <var>forced flag</var> is set, then fire a <code>close</code> event at
              <var>connection</var>. The event MUST use the <a>Event</a> interface and have its
              type set to "<code>close</code>". The event MUST NOT bubble or be cancelable.

              <aside class="note">&#9752; This behavior is new in this edition. &#9752;</aside>
            </li>
          </ol>
          <aside class="note">
            Once the <a>close pending flag</a> has been set no new transactions can be
            <a title="transaction create">created</a> using <var>connection</var>. All methods that
            <a title="transaction create">create</a> transactions first check the <a>close pending flag</a> first and
            throw an exception if it is set.
          </aside>
          <aside class="note">
            Once the <a>connection</a> is closed, this can unblock the <a>steps for running an upgrade
            transaction</a>, and the <a>steps for deleting a database</a>, which <a href="#delete-close-block">both</a>
            <a href="#version-change-close-block">wait</a> for <a title="connection">connections</a> to a given <a>database</a> to be closed
            before continuing.
          </aside>
        </section>

        <section class="section">
          <h4>Deleting a database</h4>
          <p>
            The <dfn>steps for deleting a database</dfn> are as follows.
            The algorithm in these steps takes three arguments:
            the <var>origin</var> that requested the <a>database</a> to be deleted,
            a database <var>name</var>,
            and a <var>request</var>.
          </p>
          <ol>
            <li>
              Let <var>db</var> be the <a>database</a> with the given name from the origin <var>origin</var>,
              if one exists. Otherwise, return 0 (zero).
            </li>
            <li>
              Set <var>db</var>'s <a>delete pending flag</a>.
            </li>
            <li>
              Let <var>openConnections</var> be the set of all <a title="connection">connections</a>
              associated with <var>db</var>.
            </li>
            <li>
              For each <var>entry</var> in <var>openConnections</var> that does not have its <a>close pending flag</a> set,
              <a title="fire a version change event">fire a version change event named <code>versionchange</code></a>
              at <var>entry</var> with <var>db</var>'s <a>version</a> and null.
              <aside class="note">
                Firing this event might cause one or more of the other objects in <var>openConnections</var> to be closed, in which case
                the <code>versionchange</code> event MUST NOT be fired at those objects if that hasn't yet been done.
              </aside>
            </li>
            <li>
              If any of the <a title="connection">connections</a> in <var>openConnections</var> are still not closed, and <var>request</var> was given,
              <a title="fire a version change event">fire a version change event named <code>blocked</code></a>
              at <var>request</var> with <var>db</var>'s <a>version</a> and null.
            </li>
            <li id="delete-close-block">
              Wait until all <a title="connection">connections</a> in <var>openConnections</var> are <a title="database close">closed</a> and all of
              their transactions are <a title="transaction finish">finished</a>.
            </li>
            <li>
              Let <var>version</var> be <var>db</var>'s <a>version</a>.
            </li>
            <li>
              Delete <var>db</var>.
            </li>
            <li>
              Return <var>version</var>.
            </li>
          </ol>
        </section>

        <section class="section">
          <h4>Steps for committing a transaction</h4>
          <p>
            When taking the <dfn>steps for committing a transaction</dfn> the implementation MUST
            execute the following algorithm. This algorithm takes one argument, the <var>transaction</var> to commit.
          </p>
          <ol>
            <li>
              All the changes made to the <a>database</a> by the <a>transaction</a> are written to the <a>database</a>.
            </li>
            <li>
              If an error occurs while writing the changes to the <a>database</a>, abort the transaction by following
              the <a>steps for aborting a transaction</a> with <var>transaction</var>
              and an appropriate for the error, for example <a>QuotaExceededError</a> or <a>UnknownError</a>.
            </li>
            <li>
              <a>Queue a task</a> to dispatch an event at <a>transaction</a>.
              The event must use the <a><code>Event</code></a> interface and have its <code>type</code> set to "<code>complete</code>".
              The event does not bubble and is not cancelable. The
              <a>propagation path</a> for the event is <var>transaction</var>'s <a title="transaction connection">connection</a> and
              then <var>transaction</var>.
              <aside class="note">
                Even if an exception is thrown from one of the event handlers of this event, the transaction is still
                committed since writing the database changes happens before the event takes places. Only after the transaction
                has been successfully written is the "<code>complete</code>" event fired.
              </aside>
            </li>
          </ol>
        </section>

        <section class="section">
          <h4>Steps for aborting a transaction</h4>
          <p>
            When taking the <dfn>steps for aborting a transaction</dfn> the implementation MUST
            execute the following algorithm. This algorithm takes two arguments:
            the <var>transaction</var> to abort,
            and <var>error</var>.
          </p>
          <ol>
            <li>
              All the changes made to the <a>database</a> by the <a>transaction</a> are reverted. For <a title="upgrade transaction">upgrade transactions</a>
              this includes changes to the set of <a title="object store">object stores</a> and <a title="index">indexes</a>, as well
              as the change to the <a>version</a>. Also run the <a>steps for aborting an upgrade transaction</a>
              which reverts changes to all <a>connection</a> and <a>object store handle</a> instances.
            </li>
            <li>
              If <var>error</var> is not null, set <var>transaction</var>'s <a title="transaction error">error</a>
              to <var>error</var>.
            </li>
            <li>
              For each <var>request</var> in <var>transaction</var>'s <a>request list</a>
              with <a title="request done">done flag</a> unset,
              abort the <a>steps for asynchronously executing a request</a> for <var>request</var> and
              <a>queue a task</a> to perform the following steps:
              <ol>
                <li>Set the <a title="request done">done flag</a> on <var>request</var>.</li>
                <li>Set the <a title="request result">result</a> of <var>request</var> to undefined.</li>
                <li>Set the <a title="request error">error</a> of <var>request</var> to a newly created <a>AbortError</a> exception.</li>
                <li>
                  Dispatch an event at <var>request</var>. The event must use
                  the <a><code>Event</code></a> interface and have its <code>type</code> set to "<code>error</code>".
                  The event bubbles and is cancelable. The
                  <a>propagation path</a> for the event is <var>transaction</var>'s <a title="transaction connection">connection</a>,
                  then <var>transaction</var> and finally the <a>request</a>. There is no <a>default action</a> for the event.
                </li>
              </ol>
              <aside class="note">
                This does not always result in any <code>error</code> events being fired. For example if a transaction is aborted
                due to an error while <a title="transaction commit">committing</a> the transaction, or if it was the last remaining request
                that failed.
              </aside>
            </li>
            <li>
              <a>Queue a task</a> to dispatch an event at <var>transaction</var>.
              The event must use the <a><code>Event</code></a> interface and have its <code>type</code> set to "<code>abort</code>".
              The event does bubble but is not cancelable.
              The <a>propagation path</a> for the event is <var>transaction</var>'s <a title="transaction connection">connection</a> and
              then <var>transaction</var>.
            </li>
          </ol>
        </section>

        <section class="section">
          <h4>Steps for asynchronously executing a <a>request</a></h4>
          <p>
            When taking the <dfn>steps for asynchronously executing a request</dfn> the implementation MUST run the
            following algorithm. The algorithm takes a <var>source</var> object and an <var>operation</var> to
            perform on a database, and an optional <var>request</var>.
          </p>
          <p>
            These steps can be aborted at any point if the <a>transaction</a> the created <a>request</a> belongs
            to is <a title="transaction abort">aborted</a> using the <a>steps for aborting a transaction</a>
          </p>
          <ol>
            <li>
              Let <var>transaction</var> be the <a>transaction</a> associated with <var>source</var>.
            </li>
            <li>
              If <var>transaction</var> is not <a>active</a>
              throw a <a>TransactionInactiveError</a> exception.
            </li>
            <li>
              If <var>request</var> was not given, let <var>request</var> be a new <var>request</var> with
              <a title="request source">source</a> as <var>source</var>
            </li>
            <li>
              Add <var>request</var> to the end of <var>transaction</var>'s <a>request list</a>.
            </li>
            <li>
              Return <var>request</var> and queue up the execution of the remaining steps in this algorithm.
            </li>
            <li>
              Wait until all previously added <a title="request">requests</a> in <var>transaction</var> have their
              <a title="request done">done flag</a> set.
            </li>
            <li>
              Let <var>result</var> be the result of performing <var>operation</var>.
            </li>
            <li>
              If <var>result</var> is an error, then revert all changes made by <var>operation</var>,
              set the <a title="request done">done flag</a> on <var>request</var>,
              set <a title="request result">result</a> of <var>request</var>
              to undefined and set the <a title="request error">error</a> on <var>request</var>
              to <var>result</var>.
              Finally <a>fire an error event</a> at <var>request</var>.
              <aside class="note">
                This only reverts the changes done by this request, not any other changes made by the transaction.
              </aside>
            </li>
            <li>
              Otherwise, set the <a title="request done">done flag</a>
              on the <var>request</var>, set <a title="request result">result</a> of <var>request</var>
              to <var>result</var> set the <a title="request error">error</a> of <var>request</var> to undefined.
	      Finally <a>fire a success event</a> at <var>request</var>.
            </li>
          </ol>
        </section>

        <section class="section">
          <h4>Upgrade transaction steps</h4>
          <p>
            The <dfn>steps for running an upgrade transaction</dfn> are
            as follows. This algorithm takes three arguments:
            a <var>connection</var> object which is used to update the <a>database</a>,
            a new <var>version</var> to be set for the <a>database</a>,
            and a <var>request</var>.
          </p>
          <ol>
            <li>
              Let <var>openConnections</var> be the set of all <a title="connection">connections</a>,
              except <var>connection</var>, connected to the same <a>database</a> as <var>connection</var>.
            </li>
            <li>
              For each <var>entry</var> in <var>openConnections</var> that does not have its <a>close pending flag</a> set,
              <a title="fire a version change event">fire a version change event named <code>versionchange</code></a>
              at <var>entry</var> with <var>db</var>'s <a>version</a> and <var>version</var>.
              <aside class="note">
                Firing this event might cause one or more of the other objects in <var>openConnections</var> to be closed, in which case
                the <code>versionchange</code> event MUST NOT be fired at those objects if that hasn't yet been done.
              </aside>
            </li>
            <li>
              If any of the <a title="connection">connections</a> in <var>openConnections</var> are still not closed,
              <a title="fire a version change event">fire a version change event named <code>blocked</code></a>
              at <var>request</var> with <var>db</var>'s <a>version</a> and <var>version</var>.
            </li>
            <li id="version-change-close-block">
              Wait until all <a title="connection">connections</a> in <var>openConnections</var> are <a title="database close">closed</a> and all of
              their transactions are <a title="transaction finish">finished</a>.
            </li>
            <li>
              Let <var>transaction</var> be a new <a>upgrade transaction</a> with <var>connection</var> used as <a>connection</a>.
              The <a>scope</a> of <var>transaction</var> includes every <a>object store</a> in <var>connection</var>.
            </li>
            <li>
              Unset <var>transaction</var>'s <a>active flag</a>.
            </li>
            <li>
              Start <var>transaction</var>. Note that until this <a>transaction</a> is finished,
              no other <a title="connection">connections</a> can be opened to the same <a>database</a>.
            </li>
            <li>
              Let <var>old version</var> be <var>database</var>'s <a>version</a>.
            </li>
            <li>
              Set the version of <var>database</var> to <var>version</var>. This change is considered part of the
              <a>transaction</a>, and so if the transaction is <a title="transaction abort">aborted</a>, this change is reverted.
            </li>
            <li>
              <a>Queue a task</a> to run the following steps:
              <ol>
                <li>
                  Set <var>request</var>'s <a title="request result">result</a> to <var>connection</var>.
                </li>
                <li>
                  Set <var>request</var>'s <a title="request transaction">transaction</a> to <var>transaction</var>.
                </li>
                <li>
                  Set the <a title="request done">done flag</a> on the <a>request</a>.
                </li>
                <li>
                  <a title="fire a version change event">Fire a version change event named <dfn><code>upgradeneeded</code></dfn></a>
                  at <var>request</var> with <var>old version</var> and <var>version</var>.
                </li>
                <li>
                  If an exception was propagated out from any event handler while dispatching the event in the previous step, abort
                  the transaction by following the <a>steps for aborting a transaction</a> with the <var>error</var> property set to
                  a newly created <a>AbortError</a> exception.
                </li>
              </ol>
            </li>
            <li>
              Execute transaction.
            </li>
            <li>
              If <var>transaction</var> is aborted for any reason, the <a>steps for aborting a transaction</a> MUST be run.
            </li>
            <li>
              When <var>transaction</var> is finished,
              immediately set <var>request</var>'s <a title="request transaction">transaction</a> to null.

              This MUST be done in the same task as the task firing the
              <code>complete</code> or <code>abort</code> event, but after those events has been fired.
            </li>
          </ol>
        </section>

        <section class="section">
        	<h4>Steps for aborting an upgrade transaction</h4>
        	<p>
        	  The <dfn>steps for aborting an upgrade transaction</dfn> <var>transaction</var> are as follows.
        	</p>
                <aside class="note">
                  The steps are run after the normal <a>steps for aborting a transaction</a>, which revert
                  changes to the <a>database</a> including the set of associated <a title="object store">object stores</a>
                  and <a title="index">indexes</a>, as well as the change to the <a>version</a>.
                </aside>
        	<ol>
                  <li>
                    Let <var>connection</var> be <var>transaction</var>'s <a>connection</a>.
                  </li>
                  <li>
                    Let <var>database</var> be <var>connection</var>'s <a>database</a>.
                  </li>
        	  <li>
                    Set <var>connection</var>'s <a title="connection version">version</a> to <var>database</var>'s <a>version</a>
                    if <var>database</var> previously existed,
                    or 0 (zero) if <var>database</var> was newly created
                    <aside class="note">
                      This reverts the value of <code>version</code> returned by the <a>IDBDatabase</a> object.
                    </aside>
        	  </li>
        	  <li>
                    Set <var>connection</var>'s <a>object store set</a> to the
                    set of <a title="object store">object stores</a> in <var>database</var>
                    if <var>database</var> previously existed,
                    or the empty set if <var>database</var> was newly created.
                    <aside class="note">
                      This reverts the value of <code>objectStoreNames</code> returned by the <a>IDBDatabase</a> object.
                    </aside>
        	  </li>
        	  <li>
                    For each <a>object store handle</a> <var>handle</var> associated with <var>transaction</var>,
                    including <a title="object store handle">handles</a> for <a title="object store">stores</a>
                    that were deleted during <var>transaction</var>:
                    <ol>
                      <li>
                        Set <var>handle</var>'s <a title="object store handle name">name</a> to
                        its <a title="handle object store">object store</a>'s <a title="object store name">name</a>.
                      </li>
                      <li>
                        Set <var>handle</var>'s <a>index set</a> to the
                        set of <a title="index">indexes</a> that reference its <a title="handle object store">object store</a>.
                      </li>
                    </ol>
                    <aside class="note">
                      This reverts the values of <code>name</code> and <code>indexNames</code> returned by related <a>IDBObjectStore</a> objects.

                      <p>
        	      Although script cannot access an <a>object store</a> by using the
        	      <code>objectStore()</code> method on an <a>IDBTransaction</a> instance after
                      the <a>transaction</a> is aborted, it may still have references to
                      <a>IDBObjectStore</a> instances where the <code>name</code> and <code>indexNames</code> properties
                      can be queried.
                      </p>
        	    </aside>
        	  </li>
        	  <li>
                    For each <a>index handle</a> <var>handle</var> associated with <var>transaction</var>,
                    including <a title="index handle">handles</a> for <a title="index">indexes</a>
                    that were deleted during <var>transaction</var>:
                    <ol>
                      <li>
                        Set <var>handle</var>'s <a title="index handle name">name</a> to
                        its <a title="handle index">index</a>'s <a title="index name">name</a>.
                      </li>
                    </ol>
                    <aside class="note">
                      This reverts the value of <code>name</code> returned by related <a>IDBIndex</a> objects.

                      <p>
        	        Although script cannot access an <a>index</a> by using the
        	        <code>index()</code> method on an <a>IDBObjectStore</a> instance after
                        the <a>transaction</a> is aborted, it may still have references to
                        <a>IDBIndex</a> instances where the <code>name</code> property
                        can be queried.
                      </p>
        	    </aside>
        	  </li>
        	</ol>

        	<aside class="note">
        	  The <code>name</code> property of the <a>IDBDatabase</a> instance is not modified,
        	  even if the aborted <a>upgrade transaction</a> was creating a new <a>database</a>.
                </aside>
        </section>

        <section class="section">
          <h4>Fire a success event</h4>
          <p>
            To <dfn>fire a success event</dfn> at a <a>request</a>,
            the implementation MUST run the following steps:
          </p>
          <ol>
            <li>
              Set <var>transaction</var> to the <a>transaction</a> associated with the <a title="request source">source</a>.
            </li>
            <li>
              Set the <a>active flag</a> of <var>transaction</var>.
            </li>
            <li>
              Dispatch an event at <a>request</a>. The event must use
              the <a><code>Event</code></a> interface and have its <code>type</code> set to "<code>success</code>".
              The event does not bubble and is not cancelable. The
              <a>propagation path</a> for the event is the <var>transaction</var>'s <a title="transaction connection">connection</a>,
              then <var>transaction</var> and finally <var>request</var>.
            </li>
            <li>
              Unset the <a>active flag</a> of <var>transaction</var>.
            </li>
            <li>
              If an exception was propagated out from any event handler while dispatching the event in step 3,
              abort the transaction by following the <a>steps for aborting a transaction</a> with
              <var>transaction</var> and a newly created <a>AbortError</a> exception.
            </li>
          </ol>
        </section>

        <section class="section">
          <h4>Fire an error event</h4>
          <p>
            To <dfn title="fire an error event">fire an error event</dfn> at a <a><var>request</var></a>,
            the implementation MUST run the following steps:
          </p>
          <ol>
            <li>
              Set <var>transaction</var> to the <a>transaction</a> associated with the <a title="request source">source</a>.
            </li>
            <li>
              Set the <a>active flag</a> of <var>transaction</var>.
            </li>
            <li>
              Dispatch an event at <var>request</var>. The event must use
              the <a><code>Event</code></a> interface and have its <code>type</code> set to "<code>error</code>".
              The event bubbles and is cancelable. The
              <a>propagation path</a> for the event is the <var>transaction</var>'s <a title="transaction connection">connection</a>,
              then <var>transaction</var> and finally <var>request</var>. The event's <a>default action</a> is to abort the
              <var>transaction</var> by running the <a>steps for aborting a transaction</a> using <var>transaction</var>
              and <a>request</a>'s <a title="request error">error</a>. However the <a>default action</a> is
              not taken if any of the event handlers threw an exception.
            </li>
            <li>
              Unset the <a>active flag</a> of <var>transaction</var>.
            </li>
            <li>
              If an exception was propagated out from any event handler while dispatching the event in step 3,
              abort the transaction by following the <a>steps for aborting a transaction</a> with
              <var>transaction</var> and a newly created <a>AbortError</a> exception. This is done even if the error event is not
              canceled.
              <aside class="note">
                This means that if an error event is fired and any of the event handlers throw an exception,
                <var>transaction</var>'s <code>error</code> property is set to an <a>AbortError</a> exception rather than <var>request</var>'s
                <a title="request error">error</a>, even if <code>preventDefault()</code> is never called.
              </aside>
            </li>
          </ol>
        </section>
      </section>

      <section class="section" id="database-operations">
        <h3>Database operations</h3>
        <p>
          This section describes various operations done on the data in <a title="object store">object stores</a> and <a title="index">indexes</a>
          in a <a>database</a>. These operations are run by the <a>steps for asynchronously executing a request</a>.
        </p>
        <section class="section">
          <h4>Object Store Storage Operation</h4>
          <p>
            The <dfn>steps for storing a record into an object store</dfn> with
            <var>store</var>,
            <var>value</var>,
            an optional <var>key</var>,
            and a <var>no-overwrite flag</var>
            are as follows.
          </p>
          <ol>
            <li>
              If <var>store</var> uses <a>in-line keys</a>:
              <ol>
                <li>Let <var>kpk</var> be the result of running the steps to <a>extract a key from a value using a key path</a>
                  with <var>value</var> and <var>store</var>'s <a title="object store key path">key path</a>.
                </li>
                <li>Assert: <var>kpk</var> will not be invalid or an exception.</li>
                <li>If <var>kpk</var> is not failure, let <var>key</var> be <var>kpk</var>.</li>
              </ol>
            </li>
            <li>
              If <var>store</var> uses a <a>key generator</a>:
              <ol>
                <li>
                  If <var>key</var> is undefined:
                  <ol>
                    <li>
                      If the <a>key generator</a>'s <a>current number</a> is greater than 2<sup>53</sup> (9007199254740992),
                      then this operation failed with a <a>ConstraintError</a>. Abort this algorithm without taking
                      any further steps.
                    </li>
                    <li>Set <var>key</var> to the <a>key generator</a>'s <a>current number</a></li>
                    <li>Increase the <a>key generator</a>'s <a>current number</a> by 1.</li>
                    <li>
                      If <var>store</var> also uses <a>in-line keys</a>, then run the steps to
                      <a>inject a key into a value using a key path</a> with <var>value</var>,
                      <var>key</var> and <var>store</var>'s <a title="object store key path">key path</a>.
                    </li>
                  </ol>
                </li>
                <li>
                  Otherwise, if the <a title="key type">type</a> of <var>key</var> is <i>number</i>
                  and the <a title="key value">value</a> is greater than or equal to the <a>key generator</a>'s
                  <a>current number</a>, set the <a>current number</a> to lowest integer greater than <var>key</var>.
                </li>
              </ol>
            </li>
            <li>
              If the <var>no-overwrite flag</var> was given to these steps and is set, and
              a <a>record</a> already exists in <var>store</var> with its key <a>equal to</a> <var>key</var>, then
              this operation failed with a <a>ConstraintError</a>. Abort this algorithm without taking
              any further steps.
            </li>
            <li>
              If a <a>record</a> already exists in <var>store</var> with its key <a>equal to</a> <var>key</var>, then
              remove the <a>record</a> from <var>store</var> using the <a>steps for deleting records from an object store</a>.
            </li>
            <li>
              Store a record in <var>store</var> containing <var>key</var> as its key and <var>object</var> as its
              value. The record is stored in the object store's <a title="object store record list">list</a> such
              that the list is sorted according key of the records in ascending order.
            </li>
            <li>
              For each <var>index</var> which <a title="referenced">reference</a> <var>store</var>, perform the
              following substeps:
              <ol>
                <li>
                  Let <var>index key</var> be the result of running the steps to <a>extract a key from a value using a key path</a>
                  with <var>value</var>, <var>index</var>'s <a title="index key path">key path</a>,
                  and <var>index</var>'s <a>multiEntry flag</a>.
                </li>
                <li>If <var>index key</var> is an exception, or invalid, or failure, take no further actions for this index,
                  and continue these substeps for the next index.
                  <aside class="note">
                    An exception thrown in this step is not rethrown.
                  </aside>
                </li>
                <li>
                  If <var>index</var>'s <a>multiEntry flag</a> is unset, or if <var>index key</var> is not an <a>array key</a>,
                  and if <var>index</var> already contains a <a>record</a> with <a>key</a> <a>equal to</a> <var>index key</var>,
                  and <var>index</var> has its <a>unique flag</a> set, then this operation failed with a
                  <a>ConstraintError</a>. Abort this algorithm without taking any further steps.
                </li>
                <li>
                  If <var>index</var>'s <a>multiEntry flag</a> is set and <var>index key</var> is an <a>array key</a>,
                  and if <var>index</var> already contains a <a>record</a> with <a>key</a> <a>equal to</a> any of the
                  <a>subkeys</a> of <var>index key</var>, and <var>index</var> has its <a>unique flag</a> set, then this operation
                  failed with a <a>ConstraintError</a>. Abort this algorithm without taking any further steps.
                </li>
                <li>
                  If <var>index</var>'s <a>multiEntry flag</a> is unset, or if <var>index key</var> is not an <a>array key</a>
                  then store a record in <var>index</var> containing <var>index key</var> as its key and <var>key</var> as its
                  value. The record is stored in <var>index</var>'s <a title="index record list">list of records</a> such
                  that the list is sorted primarily on the records keys, and secondarily on the records values, in ascending
                  order.
                </li>
                <li>
                  If <var>index</var>'s <a>multiEntry flag</a> is set and <var>index key</var> is an <a>array key</a>,
                  then for each <var>subkey</var> of the <a>subkeys</a> of <var>index key</var> store a record in <var>index</var> containing
                  <var>subkey</var> as its key and <var>key</var> as its value. The records are stored in <var>index</var>'s
                  <a title="index record list">list of records</a> such that the list is sorted primarily on the records keys,
                  and secondarily on the records values, in ascending order.
                  <aside class="note">
                    It is valid for there to be no <a>subkeys</a>. In this case no records are added to the index.
                  </aside>
                  <aside class="note">
                    Even if any member of <a>subkeys</a> is an <a>array key</a>, the member is used directly
                    as the key for the index record. Nested <a title="array key">array keys</a> are not flattened
                    or "unpacked" to produce multiple rows; only the outer-most <a>array key</a>
                  </aside>
                </li>
              </ol>
            </li>
            <li>
              Return <var>key</var>.
            </li>
          </ol>
        </section>

        <section class="section">
          <h4>Object Store Retrieval Operations</h4>
          <p>
            The <dfn>steps for retrieving a value from an object store</dfn> with
            <var>store</var> and <var>range</var> are as follows:
          </p>

          <ol>
            <li>
              Let <var>record</var> be the first <a>record</a> in <var>store</var>'s <a title="object store record list">list of records</a>
              whose key is <a title="in a key range">in</a> <var>range</var>,
              if any.
            </li>
            <li>
              If <var>record</var> was not found, return undefined.
            </li>
            <li>
              Return a <a>structured clone</a> of <var>record</var>'s value.
            </li>
          </ol>

          <p>
            The <dfn>steps for retrieving multiple values from an object store</dfn> with
            <var>store</var>, <var>range</var> and optional <var>count</var> are as follows:
          </p>

          <ol>
            <li>If <var>count</var> is not given, let <var>count</var> be infinity.</li>
            <li>
              Let <var>records</var> be a list containing the first <var>count</var> <a title="record">records</a>
              in <var>store</var>'s <a title="object store record list">list of records</a>
              whose key is <a title="in a key range">in</a> <var>range</var>.
            </li>
            <li>Let <var>array</var> be a new <code>Array</code> object.</li>
            <li>Let <var>index</var> be 0.</li>
            <li>For each <var>record</var> in <var>records</var>:
              <ol>
                <li>Let <var>entry</var> be a <a>structured clone</a> of <var>record</var>'s value.</li>
                <li>Let <var>status</var> be CreateDataProperty(<var>array</var>, <var>index</var>, <var>entry</var>).</li>
                <li>Assert: <var>status</var> is true.</li>
                <li>Increase <var>index</var> by 1.</li>
              </ol>
            </li>
            <li>Return <var>array</var></li>
          </ol>

          <p>
            The <dfn>steps for retrieving multiple keys from an object store</dfn> with
            <var>store</var>, <var>range</var> and optional <var>count</var> are as follows:
          </p>

          <ol>
            <li>If <var>count</var> is not given, let <var>count</var> be infinity.</li>
            <li>
              Let <var>records</var> be a list containing the first <var>count</var> <a title="record">records</a>
              in <var>store</var>'s <a title="object store record list">list of records</a>
              whose key is <a title="in a key range">in</a> <var>range</var>.
            </li>
            <li>Let <var>array</var> be a new <code>Array</code> object.</li>
            <li>Let <var>index</var> be 0.</li>
            <li>For each <var>record</var> in <var>records</var>:
              <ol>
                <li>Let <var>entry</var> be the result of running the steps to <a>convert a key to a value</a> with <var>record</var>'s key.</li>
                <li>Let <var>status</var> be CreateDataProperty(<var>array</var>, <var>index</var>, <var>entry</var>).</li>
                <li>Assert: <var>status</var> is true.</li>
                <li>Increase <var>index</var> by 1.</li>
              </ol>
            </li>
            <li>Return <var>array</var></li>
          </ol>
        </section>

        <section class="section">
          <h4>Index Retrieval Operations</h4>
          <p>
            The <dfn>steps for retrieving a referenced value from an index</dfn> with
            <var>index</var> and <var>range</var> are as follows.
          </p>
          <ol>
            <li>
              Let <var>record</var> be the first <a>record</a>
              in <var>index</var>'s <a title="index record list">list of records</a>
              whose key is <a title="in a key range">in</a> <var>range</var>,
              if any.
            </li>
            <li>
              If <var>record</var> was not found, return undefined.
            </li>
            <li>
              Return a <a>structured clone</a> of <var>record</var>'s <a>referenced value</a>.
            </li>
          </ol>

          <p>
            The <dfn>steps for retrieving multiple referenced values from an index</dfn> with
            <var>index</var>, <var>range</var> and optional <var>count</var> are as follows:
          </p>

          <ol>
            <li>If <var>count</var> is not given, let <var>count</var> be infinity.</li>
            <li>
              Let <var>records</var> be a list containing the first <var>count</var> <a title="record">records</a>
              in <var>index</var>'s <a title="index record list">list of records</a>
              whose key is <a title="in a key range">in</a> <var>range</var>.
            </li>
            <li>Let <var>array</var> be a new <code>Array</code> object.</li>
            <li>Let <var>index</var> be 0.</li>
            <li>For each <var>record</var> in <var>records</var>:
              <ol>
                <li>Let <var>entry</var> be a <a>structured clone</a> of <var>record</var>'s <a>referenced value</a>.</li>
                <li>Let <var>status</var> be CreateDataProperty(<var>array</var>, <var>index</var>, <var>entry</var>).</li>
                <li>Assert: <var>status</var> is true.</li>
                <li>Increase <var>index</var> by 1.</li>
              </ol>
            </li>
            <li>Return <var>array</var></li>
          </ol>

          <p>
            The <dfn>steps for retrieving a value from an index</dfn> with
            <var>index</var> and <var>range</var> are as follows.
          </p>

          <ol>
            <li>
              Let <var>record</var> be the first <a>record</a>
              in <var>index</var>'s <a title="index record list">list of records</a>
              whose key is <a title="in a key range">in</a> <var>range</var>,
              if any.
            </li>
            <li>
              If <var>record</var> was not found, return undefined.
            </li>
            <li>
              Return <var>record</var>'s <a>value</a>.
            </li>
          </ol>

          <p>
            The <dfn>steps for retrieving multiple values from an index</dfn> with
            <var>index</var>, <var>range</var> and optional <var>count</var> are as follows:
          </p>

          <ol>
            <li>If <var>count</var> is not given, let <var>count</var> be infinity.</li>
            <li>
              Let <var>records</var> be a list containing the first <var>count</var> <a title="record">records</a>
              in <var>index</var>'s <a title="index record list">list of records</a>
              whose key is <a title="in a key range">in</a> <var>range</var>.
            </li>
            <li>Let <var>array</var> be a new <code>Array</code> object.</li>
            <li>Let <var>index</var> be 0.</li>
            <li>For each <var>record</var> in <var>records</var>:
              <ol>
                <li>Let <var>entry</var> be the result of running the steps to <a>convert a key to a value</a> with <var>record</var>'s value.</li>
                <li>Let <var>status</var> be CreateDataProperty(<var>array</var>, <var>index</var>, <var>entry</var>).</li>
                <li>Assert: <var>status</var> is true.</li>
                <li>Increase <var>index</var> by 1.</li>
              </ol>
            </li>
            <li>Return <var>array</var></li>
          </ol>
        </section>

        <section class="section">
          <h4>Object Store Deletion Operation</h4>
          <p>
            The <dfn>steps for deleting records from an object store</dfn>
            with <var>store</var> and <var>range</var> are as follows.
          </p>
          <ol>
            <li>
              Remove all records, if any, from <var>store</var>'s <a title="object store record list">list of records</a>
              with key <a title="in a key range">in</a> <var>range</var>.
            </li>
            <li>
              For each <var>index</var> which <a title="referenced">references</a> <var>store</var>, remove
              every <a>record</a> from <var>index</var>'s <a title="index record list">list of records</a>
              whose value is <a title="in a key range">in</a> <var>range</var>, if any such records exist.
            </li>
            <li>
              Return undefined.
            </li>
          </ol>
        </section>

        <section class="section">
          <h4>Record Counting Operation</h4>
          <p>
            The <dfn>steps to count the records in a range</dfn> with <var>source</var> and <var>range</var> are as follows:
          </p>
          <ol>
            <li>
              Let <var>count</var> be the number of records, if any,
              in <var>source</var>'s list of records with key <a title="in a key range">in</a> <var>range</var>.
            </li>
            <li>
              Return <var>count</var>.
            </li>
          </ol>
        </section>

        <section class="section">
          <h4>Object Store Clear Operation</h4>
          <p>
            The <dfn>steps for clearing an object store</dfn> with <var>store</var> are as follows.
          </p>
          <ol>
            <li>
               Remove all records from <var>store</var>.
            </li>
            <li>
              In all <a title="index">indexes</a> which <a title="referenced">reference</a> <var>store</var>, remove all
              <a title="record">records</a>.
            </li>
            <li>
              Return undefined.
            </li>
          </ol>
        </section>

        <section class="section">
          <h4>Cursor Iteration Operation</h4>
          <p>
            The <dfn>steps for iterating a cursor</dfn> with <var>cursor</var>, an optional
            <var>key</var> and <var>primaryKey</var> to iterate to, and an optional <var>count</var> are as follows.
          </p>
          <ol>
            <li>Let <var>source</var> be <var>cursor</var>'s <a title="cursor source">source</a>.</li>
            <li>Let <var>direction</var> be <var>cursor</var>'s <a>direction</a>.</li>
            <li>Assert: if <var>primaryKey</var> is given, <var>source</var> is an <a>index</a> and
              <var>direction</var> is "<code>next</code>" or "<code>prev</code>".
            </li>
            <li>Let <var>records</var> be the list of <a title="record">records</a> in <var>source</var>.
              <aside class="note">
                <var>records</var> is always sorted in ascending <a>key</a> order. In the case of
                <var>source</var> being an <a>index</a>, <var>records</var> is secondarily sorted in ascending
                <a>value</a> order (where the value in an <a>index</a> is the <a>key</a> of the <a>record</a> in the referenced <a>object store</a>).
              </aside>
            </li>
            <li>Let <var>range</var> be <var>cursor</var>'s <a>range</a>.</li>

            <li>Let <var>position</var> be <var>cursor</var>'s <a>position</a>.</li>
            <li>Let <var>object store position</var> be <var>cursor</var>'s <a>object store position</a>.</li>

            <li>If <var>count</var> is not given, let <var>count</var> be 1.</li>
            <li>While <var>count</var> is greater than 0:
              <ol>
                <li>
                  Switch on <var>direction</var>:
                  <dl class="switch">
                    <dt>"<code>next</code>"</dt>
                    <dd>
                      Let <var>found record</var> be the first record in <var>records</var> which
                      satisfy all of the following requirements:
                      <ul>
                        <li>
                          If <var>key</var> is defined, the record's key is <a>greater than</a> or <a>equal to</a> <var>key</var>.
                        </li>
                        <li>
                          If <var>primaryKey</var> is defined,
                          the record's key is <a>equal to</a> <var>key</var>
                          and the record's value is <a>greater than</a> or <a>equal to</a> <var>primaryKey</var>, or
                          the record's key is <a>greater than</a> <var>key</var>.
                        </li>
                        <li>
                          If <var>position</var> is defined, and <var>source</var> is an <a>object store</a>, the record's
                          key is <a>greater than</a> <var>position</var>.
                        </li>
                        <li>
                          If <var>position</var> is defined, and <var>source</var> is an <a>index</a>, the record's
                          key is <a>equal to</a> <var>position</var> and the record's value is <a>greater than</a>
                          <var>object store position</var> or the record's key is <a>greater than</a> <var>position</var>.
                        </li>
                        <li>
                          The record's key is <a title="in a key range">in</a> <var>range</var>.
                        </li>
                      </ul>
                    </dd>
                    <dt>"<code>nextunique</code>"</dt>
                    <dd>
                      Let <var>found record</var> be the first record in <var>records</var> which
                      satisfy all of the following requirements:
                      <ul>
                        <li>
                          If <var>key</var> is defined, the record's key is <a>greater than</a> or <a>equal to</a> <var>key</var>.
                        </li>
                        <li>
                          If <var>position</var> is defined, the record's key is <a>greater than</a> <var>position</var>.
                        </li>
                        <li>
                          The record's key is <a title="in a key range">in</a> <var>range</var>.
                        </li>
                      </ul>
                    </dd>
                    <dt>"<code>prev</code>"</dt>
                    <dd>
                      Let <var>found record</var> be the last record in <var>records</var> which
                      satisfy all of the following requirements:
                      <ul>
                        <li>
                          If <var>key</var> is defined, the record's key is <a>less than</a> or <a>equal to</a> <var>key</var>.
                        </li>
                        <li>
                          If <var>primaryKey</var> is defined,
                          the record's key is <a>equal to</a> <var>key</var>
                          and the record's value is <a>less than</a> or <a>equal to</a> <var>primaryKey</var>, or
                          the record's key is <a>less than</a> <var>key</var>.
                        </li>
                        <li>
                          If <var>position</var> is defined, and <var>source</var> is an <a>object store</a>, the record's
                          key is <a>less than</a> <var>position</var>.
                        </li>
                        <li>
                          If <var>position</var> is defined, and <var>source</var> is an <a>index</a>, the record's
                          key is <a>equal to</a> <var>position</var> and the record's value is <a>less than</a>
                          <var>object store position</var> or the record's key is <a>less than</a> <var>position</var>.
                        </li>
                        <li>
                          The record's key is <a title="in a key range">in</a> <var>range</var>.
                        </li>
                      </ul>
                    </dd>
                    <dt>"<code>prevunique</code>"</dt>
                    <dd>
                      Let <var>temp record</var> be the last record in
                      <var>records</var> which satisfy all of the following requirements:
                      <ul>
                        <li>
                          If <var>key</var> is defined, the record's key is <a>less than</a> or <a>equal to</a> <var>key</var>.
                        </li>
                        <li>
                          If <var>position</var> is defined, the record's key is <a>less than</a> <var>position</var>.
                        </li>
                        <li>
                          The record's key is <a title="in a key range">in</a> <var>range</var>.
                        </li>
                      </ul>
                      If <var>temp record</var> is defined, let <var>found record</var> be the first record in <var>records</var>
                      whose key is <a>equal to</a> <var>temp record</var>'s key.
                    </dd>
                  </dl>
                </li>
                <li>
                  If <var>found record</var> is not defined:
                  <ol>
                    <li>Set <var>cursor</var>'s <a title="cursor key">key</a> to undefined.</li>
                    <li>If <var>source</var> is an <a>index</a>,
                      set <var>cursor</var>'s <a>object store position</a> to undefined.</li>
                    <li>If <var>cursor</var>'s <a>key only flag</a> is unset,
                      set <var>cursor</var>'s <a title="cursor value">value</a> to undefined.</li>
                    <li>Return null.</li>
                  </ol>
                </li>

                <li>Let <var>position</var> be <var>found record</var>'s key.</li>
                <li>If <var>source</var> is an <a>index</a>,
                  let <var>object store position</var> be <var>found record</var>'s value.</li>
                <li>Decrease <var>count</var> by 1.</li>
              </ol>

              <li>Set <var>cursor</var>'s <a>position</a> to <var>position</var>.</li>
              <li>If <var>source</var> is an <a>index</a>,
                set <var>cursor</var>'s <a>object store position</a> to <var>object store position</var>.</li>
              <li>Set <var>cursor</var>'s <a title="cursor key">key</a> to <var>found record</var>'s key.</li>
              <li>If <var>cursor</var>'s <a>key only flag</a> is unset,
                set <var>cursor</var>'s <a title="cursor value">value</a> to a <a>structured clone</a> of <var>found record</var>'s <a>referenced value</a>.</li>
              <li>Set <var>cursor</var>'s <a>got value flag</a>.</li>
            <li>Return <var>cursor</var>.</li>
          </ol>
        </section>
      </section>

      <section class="section" id="binding">
        <h3>ECMAScript binding</h3>

        <p>
          This section defines how <a>key</a> values defined in this specification
          are converted to and from ECMAScript values, and how they may be
          extracted from and injected into ECMAScript values using <a title="key path">key paths</a>.
          This section references
          types and algorithms from the ECMAScript Language Specification. [[!ECMA-262]]
        </p>

        <section class="section">
          <h4>Steps to extract a key from a value using a <a>key path</a></h4>

          <p>
            The steps to <dfn>extract a key from a value using a key path</dfn>
            with <var>value</var>, <var>keyPath</var> and an optional
            <var>multiEntry flag</var> are as follows.
            The result of these steps is a <a>key</a>, invalid, or failure,
            or the steps may throw an exception.
          </p>
          <ol>
            <li>
              Let <var>r</var> be the result of running the steps to
              <a>evaluate a key path on a value</a> with <var>value</var> and <var>keyPath</var>.
              If this throws an exception, <a title="throw">rethrow</a> it.
            </li>
            <li>If <var>r</var> is failure, return failure.</li>
            <li>Let <var>key</var> be
              the result of running the steps to <a>convert a value to a key</a> with <var>r</var> if the <var>multiEntry flag</var> is unset, and
              the result of running the steps to <a>convert a value to a multiEntry key</a> with <var>r</var> otherwise.
              If this throws an exception, <a title="throw">rethrow</a> it.</li>
            <li>If <var>key</var> is invalid, return invalid.</li>
            <li>Return <var>key</var>.</li>
          </ol>

          <p>
            The steps to <dfn>evaluate a key path on a value</dfn>
            with <var>value</var> and <var>keyPath</var> are as follows.
            The result of these steps is an ECMAScript value
            or failure, or the steps may throw an exception.
          </p>
          <ol>
            <li>
              If <var>keyPath</var> is a <a>sequence&lt;DOMString&gt;</a>, run these substeps:
              <ol>
                <li>Let <var>result</var> be a new <code>Array</code> ECMAScript object.</li>
                <li>For each <var>item</var> in the <var>keyPath</var> sequence, perform the following substeps:
                  <ol>
                    <li>Let <var>key</var> be the result of recursively running the steps to <a>extract a key from a value using a key path</a>
                      using <var>item</var> as <var>keyPath</var> and <var>value</var> as <var>value</var>.</li>
                    <li>ReturnIfAbrupt(<var>key</var>)</li>
                    <li>If <var>key</var> is failure, abort the overall algorithm and return failure.</li>
                    <li>Append the result of the first sub-step to end of <var>result</var>.</li>
                  </ol>
                </li>
                <li>
                  Return <var>result</var>.
                  <aside class="note">
                    This will only ever "recurse" one level since <a>key path</a> sequences can't ever be nested.
                  </asider>
                </li>
              </ol>
            </li>
            <li>
              If <var>keyPath</var> is the empty string, return <var>value</var> and skip the remaining steps.
            </li>
            <li>
              Let <var>identifiers</var> be the result of <a title="strictly split a string">strictly splitting the string</a> <var>keyPath</var> on
              U+002E FULL STOP characters (.).
            </li>
            <li>
              For each <var>identifier</var> in <var>identifiers</var>:
              <ol>
                <li>If Type(<var>value</var>) is String, and <var>identifier</var> is the last item in <var>identifiers</var>,
                  and <var>identifier</var> is "<code>length</code>", return a Number equal to the number of elements in <var>value</var>.</li>
                <li>If Type(<var>identifier</var>) is not Object, return failure.
                <li>Let <var>value</var> be <var>value</var>.[<span>[</span>Get]](<var>identifier</var>, <var>value</var>)</li>
                <li>ReturnIfAbrupt(<var>value</var>)</li>
                <li>If <var>value</var> is Undefined, return failure.
              </ol>
            </li>
            <li>
              Return <var>value</var>.
            </li>
          </ol>
        </section>

        <section class="section">
          <h4>Steps to inject a key into a value using a key path</h4>
          <p>
            The steps to <dfn>inject a key into a value using a key path</dfn> are as follows.
            The algorithm takes a <var>value</var>, a <var>key</var> and a <var>keyPath</var>.
          </p>
          <ol>
            <li>
              Let <var>identifiers</var> be the result of
              <a title="strictly split a string">strictly splitting the string</a>
              <var>keyPath</var> on U+002E FULL STOP characters (.).
            </li>
            <li>Assert: <var>identifiers</var> is not empty.</li>
            <li>
              Let <var>last</var> be the last member of <var>identifiers</var>
              and remove it from the list.
            </li>
            <li>For each remaining <var>identifier</var> in <var>identifiers</var>:
              <ol>
                <li>
                  If <var>value</var> is not an <code>Object</code> object or an <code>Array</code>
                  object (see <a>structured clone algorithm</a> [[!HTML5]]), then
                  throw a <a>DataError</a> exception.
                </li>
                <li>Let <var>hop</var> be HasOwnProperty(<var>value</var>, <var>identifier</var>)</li>
                <li>ReturnIfAbrupt(<var>hop</var>)</li>
                <li>
                  If <var>hop</var> is false:
                  <ol>
                    <li>Let <var>o</var> be a new <code>Object</code>.</li>
                    <li>Let <var>status</var> be
                      CreateDataProperty(<var>value</var>, <var>identifier</var>, <var>o</var>)</li>
                    <li>Assert: <var>status</var> is true</li>
                  </ol>
                </li>
                <li>Let <var>value</var> be
                  <var>value</var>[<span>[</span>Get]](<var>identifier</var>, <var>value</var>)</li>
                <li>Assert: <var>value</var> is not an abrupt completion.</li>
              </ol>
            </li>
            <li>Assert: <var>value</var> is an <code>Object</code> or an <code>Array</code>.</li>
            <li>Let <var>keyValue</var> be the result of running the steps to
              <a>convert a key to a value</a>.</li>
            <li>Let <var>status</var> be
              CreateDataProperty(<var>value</var>, <var>identifier</var>, <var>keyValue</var>)</li>
            <li>Assert: <var>status</var> is true</li>
          </ol>

          <aside class="note">
            The <a>key path</a> used here is always a string and never a sequence, since it is not
            possible to create a <a>object store</a> which has a <a>key generator</a> and
            also has a <a title="object store key path">key path</a> that is a sequence.
          </aside>
	</section>

        <section class="section">
          <h4>Steps to convert a key to a value</h4>
          <p>
            The steps to <dfn>convert a key to a value</dfn> are as follows. These
            steps take one argument, <var>key</var>, and return an ECMAScript value.
          </p>
          <ol>
            <li>Let <var>type</var> be <var>key</var>'s <a title="key type">type</a>.</li>
            <li>Let <var>value</var> be <var>key</var>'s <a title="key value">value</a>.</li>
            <li>Switch on <var>type</var>:
              <dl class="switch">
                <dt><i>number</i></dt>
                <dd>Return an ECMAScript Number value equal to <var>value</var></dd>

                <dt><i>string</i></dt>
                <dd>Return an ECMAScript String value equal to <var>value</var></dd>

                <dt><i>date</i></dt>
                <dd>
                  <ol>
                    <li>Let <var>date</var> be the result of executing the ECMAScript Date constructor with
                      the single argument <var>value</var></li>
                    <li>Assert: <var>date</var> is not an abrupt completion.</li>
                    <li>Return <var>date</var>
                  </ol>
                </dd>

                <dt><i>binary</i></dt>
                <dd>
                  <ol>
                    <li>Let <var>len</var> be the length of <var>value</var>.</li>
                    <li>Let <var>buffer</var> be the result of executing the ECMAScript ArrayBuffer constructor with <var>len</var>.</li>
                    <li>Assert: <var>buffer</var> is not an abrupt completion.</li>
                    <li>Set the entries in <var>buffer</var>'s [<span>[</span>ArrayBufferData]] internal slot to the entries in <var>value</var>.</li>
                    <li>Return <var>buffer</var></li>
                  </ol>
                </dd>

                <dt><i>array</i></dt>
                <dd>
                  <ol>
                    <li>Let <var>array</var> be the result of executing the ECMAScript Array constructor with no arguments.</li>
                    <li>Assert: <var>array</var> is not an abrupt completion.</li>
                    <li>Let <var>len</var> be the length of <var>value</var>.</li>
                    <li>Let <var>index</var> be 0.</li>
                    <li>While <var>index</var> is less than <var>len</var>:
                      <ol>
                        <li>Let <var>entry</var> be the result of running the steps to <a>convert a key to a value</a>
                          with the <var>index</var>th entry of <var>value</var> as input.</li>
                        <li>Let <var>status</var> be CreateDataProperty(<var>array</var>, <var>index</var>, <var>entry</var>).</li>
                        <li>Assert: <var>status</var> is true.</li>
                        <li>Increase <var>index</var> by 1.</li>
                      </ol>
                    </li>
                    <li>Return <var>array</var></li>
                  </ol>
                </dd>
              </dl>
            </li>
          </ol>
        </section>

        <section class="section">
          <h4>Steps to convert a value to a key</h4>
          <p>
            The steps to <dfn>convert a value to a key</dfn> are as follows. These
            steps take two arguments, an ECMAScript value <var>input</var>, and
            an optional set <var>seen</var>. The result of these steps is a <a>key</a> or invalid,
            or the steps may throw an exception.
          </p>
          <ol>
            <li>If <var>seen</var> was not given, let <var>seen</var> be a new empty set</li>
            <li>If <var>input</var> is in <var>seen</var> return invalid</li>
            <li>Jump to the appropriate step below:
              <dl class="switch">

                <!-- Number -->
                <dt>If Type(<var>input</var>) is Number</dt>
                <dd>
                  <ol>
                    <li>If <var>input</var> is <code>NaN</code> then return invalid.</li>
                    <li>Otherwise, return a new <a>key</a> with <a title="key type">type</a> <i>number</i>
                      and <a title="key value">value</a> <var>input</var></li>
                  </ol>
                </dd>

                <!-- Date -->
                <dt>If <var>input</var> has an [<span>[</span>DateValue]] internal slot</dt>
                <dd>
                  <ol>
                    <li>Let <var>ms</var> be the value of <var>input</var>'s [<span>[</span>DateValue]] internal slot.</li>
                    <li>If <var>ms</var> is <code>NaN</code> then return invalid.</li>
                    <li>Otherwise, return <a title="key type">type</a> <i>date</i> and <a title="key value">value</a> <var>ms</var>.</li>
                  </ol>
                </dd>

                <!-- String -->
                <dt>If Type(<var>input</var>) is String</dt>
                <dd>
                  <ol>
                    <li>Return <a title="key type">type</a> <i>string</i> and <a title="key value">value</a> <var>input</var>.</li>
                  </ol>
                </dd>

                <!-- Binary -->
                <dt>If <var>input</var> has an [<span>[</span>ArrayBufferData]] internal slot
                  or an [<span>[</span>ViewedArrayBuffer]] internal slot</dt>
                <dd>
                  <ol>
                    <li>
                      Let <var>octets</var> be the result of running the steps for
                      <a>getting a copy of the bytes held by a buffer source</a> with <var>value</var>.
                    </li>
                    <li>Return <a title="key type">type</a> <i>binary</i> and <a title="key value">value</a> <var>octets</var>.</li>
                  </ol>
                </dd>

                <!-- Array -->
                <dt>If IsArray(<var>input</var>)</dt>
                <dd>
                  <ol>
                    <li>Let <var>len</var> be the ToLength(Get(<var>input</var>, "<code>length</code>"))</li>
                    <li>Assert: <var>len</var> will never an abrupt completion.</li>
                    <li>Add <var>input</var> to <var>seen</var></li>
                    <li>Let <var>keys</var> be a new empty list</li>
                    <li>Let <var>index</var> be 0</li>
                    <li>While <var>index</var> is less than <var>len</var>:
                      <ol>
                        <li>Let <var>entry</var> be <var>input</var>.[<span>[</span>Get]](<var>index</var>, <var>input</var>)</li>
                        <li>ReturnIfAbrupt(<var>entry</var>)</li>
                        <li>Let <var>key</var> be the result of running the steps to <a>convert a value to a key</a>
                          with arguments <var>entry</var> and <var>seen</var></li>
                        <li>ReturnIfAbrupt(<var>key</var>)</li>
                        <li>If <var>key</var> is invalid or an exception, then abort these steps and return <var>key</var>.</li>
                        <li>Append <var>key</var> to <var>keys</var></li>
                        <li>Increase <var>index</var> by 1</li>
                      </ol>
                    </li>
                    <li>Return a new <a>array key</a> with <a title="key value">value</a> <var>keys</var>.</li>
                  </ol>
                </dd>

                <dt>Otherwise</dt>
                <dd>Return invalid</dd>
              </dl>
            </li>
          </ol>

          <p>
            The steps to <dfn>convert a value to a multiEntry key</dfn> are as follows. These
            steps take one argument, an ECMAScript value <var>input</var>.
            The result of these steps is a <a>key</a> or invalid, or the steps may throw an exception.
          </p>
          <ol>
            <!-- Array -->
            <li>If IsArray(<var>input</var>), then:
              <ol>
                <li>Let <var>len</var> be the ToLength(Get(<var>input</var>, "<code>length</code>")).</li>
                <li>Assert: <var>len</var> will never an abrupt completion.</li>
                <li>Let <var>seen</var> be a new set containing only <var>input</var>.</li>
                <li>Let <var>keys</var> be a new empty set.</li>
                <li>Let <var>index</var> be 0.</li>
                <li>While <var>index</var> is less than <var>len</var>:
                  <ol>
                    <li>Let <var>entry</var> be <var>input</var>.[<span>[</span>Get]](<var>index</var>, <var>input</var>)</li>
                    <li>If <var>entry</var> is not an exception:
                      <ol>
                        <li>Let <var>key</var> be the result of running the steps to <a>convert a value to a key</a>
                          with arguments <var>entry</var> and <var>seen</var></li>
                        <li>If <var>key</var> is not invalid or an exception, add <var>key</var> to <var>keys</var>
                          if there are no other members of <var>keys</var> <a>equal to</a> <var>key</var></li>
                      </ol>
                    </li>
                    <li>Increase <var>index</var> by 1</li>
                  </ol>
                </li>
                <li>Return a new <a>array key</a> with <a title="key value">value</a> set to
                  a list of the members of <var>keys</var>.
                </li>
              </ol>
            </li>
            <li>Otherwise, return the result of running the steps to <a>convert a value to a key</a>
              with argument <var>input</var>.
            </li>
          </ol>

          <aside class="note">
            <p>
              These steps are similar to those to <a>convert a value to a key</a> but if the top-level
              value is an <code>Array</code> then members which can not be converted to keys are ignored, and
              duplicates are removed.
            </p>
            <p>
              For example, the value <code>[10, 20, null, 30, 20]</code> is converted to an
              <a>array key</a> with <a>subkeys</a> 10, 20, 30.
            </p>
          </aside>
        </section>

      </section>

  <!-- database-api -->
    </section>

            <section id="privacy" class="informative">
      <h2>Privacy</h2>

      <section id="user-tracking" class="section">
        <h3>User tracking</h3>

        <p>
          A third-party host (or any object capable of getting content
          distributed to multiple sites) could use a unique identifier
          stored in its client-side database to track a user across multiple
          sessions, building a profile of the user's activities. In conjunction
          with a site that is aware of the user's real id object (for
          example an e-commerce site that requires authenticated credentials),
          this could allow oppressive groups to target individuals with
          greater accuracy than in a world with purely anonymous Web usage.
        </p>

        <p>
          There are a number of techniques that can be used to mitigate the
          risk of user tracking:
        </p>

        <dl>
          <dt>Blocking third-party storage</dt>
          <dd>
            User agents MAY restrict access to the database objects
            to scripts originating at the domain of the top-level document of
            the <span>browsing context</span>, for instance denying access to
            the API for pages from other domains running in <code>iframe</code>s.
          </dd>

          <dt>Expiring stored data</dt>
          <dd>
            <p>User agents MAY automatically delete stored data after a period
            of time.</p>

            <p>This can restrict the ability of a site to track a user, as the
            site would then only be able to track the user across multiple
            sessions when he authenticates with the site itself (e.g. by
            making a purchase or logging in to a service).</p>

            <p>However, this also puts the user's data at risk.</p>
          </dd>

          <dt>Treating persistent storage as cookies</dt>
          <dd>
            <p>User agents should present the database feature
            to the user in a way that associates them strongly with HTTP
            session cookies. [[COOKIES]]</p>

            <p>This might encourage users to view such storage with healthy
            suspicion.</p>
          </dd>

          <dt>Site-specific white-listing of access to databases</dt>
          <dd>
            <p>User agents MAY require the user to authorize access to
            databases before a site can use the feature.</p>
          </dd>

          <dt>Origin-tracking of stored data</dt>
          <dd>
            <p>User agents MAY record the <span title="origin">origins</span>
            of sites that contained content from third-party origins that
            caused data to be stored.</p>

            <p>If this information is then used to present the view of data
            currently in persistent storage, it would allow the user to make
            informed decisions about which parts of the persistent storage to
            prune. Combined with a blacklist ("delete this data and prevent
            this domain from ever storing data again"), the user can restrict
            the use of persistent storage to sites that he trusts.</p>
          </dd>

          <dt>Shared blacklists</dt>
          <dd>
            <p>User agents MAY allow users to share their persistent storage
            domain blacklists.</p>

            <p>This would allow communities to act together to protect their
            privacy.</p>
          </dd>
        </dl>

        <p>
          While these suggestions prevent trivial use of this API for user
          tracking, they do not block it altogether. Within a single domain, a
          site can continue to track the user during a session, and can then
          pass all this information to the third party along with any
          identifying information (names, credit card numbers, addresses)
          obtained by the site. If a third party cooperates with multiple
          sites to obtain such information, a profile can still be
          created.
        </p>

        <p>
          However, user tracking is to some extent possible even with no
          cooperation from the user agent whatsoever, for instance by using
          session identifiers in URLs, a technique already commonly used for
          innocuous purposes but easily repurposed for user tracking (even
          retroactively). This information can then be shared with other
          sites, using using visitors' IP addresses and other user-specific
          data (e.g. user-agent headers and configuration settings) to combine
          separate sessions into coherent user profiles.
        </p>
      </section>

      <section id="cookie-resurrection" class="section">
        <h3>Cookie resurrection</h3>

        <p>
          If the user interface for persistent storage presents data in the
          persistent storage features described in this specification
          separately from data in HTTP session cookies, then users are likely
          to delete data in one and not the other. This would allow sites to
          use the two features as redundant backup for each other, defeating a
          user's attempts to protect his privacy.
        </p>
      </section>

      <section id="sensitivity-of-data" class="section">
        <h3>Sensitivity of data</h3>

        <p>
          User agents should treat persistently stored data as potentially
          sensitive; it is quite possible for e-mails, calendar appointments,
          health records, or other confidential documents to be stored in this
          mechanism.
        </p>

        <p>To this end, user agents should ensure that when deleting data,
          it is promptly deleted from the underlying storage.
        </p>
      </section>
    </section> <!-- Privacy -->

    <section id="authorization" class="informative">
      <h2>Authorization</h2>

      <section id="dns-spoofing-attacks" class="section">
        <h3>DNS spoofing attacks</h3>

        <p>
          Because of the potential for DNS spoofing attacks, one cannot
          guarantee that a host claiming to be in a certain domain really is
          from that domain. To mitigate this, pages can use SSL. Pages using
          SSL can be sure that only pages using SSL that have certificates
          identifying them as being from the same domain can access their
          databases.
        </p>
      </section>

      <section id="cross-directory-attacks" class="section">
        <h3>Cross-directory attacks</h3>

        <p>
          Different authors sharing one host name, for example users
          hosting content on <code>geocities.com</code>, all share one
          set of databases.
        </p>

        <p>
          There is no feature to restrict the access by pathname. Authors on
          shared hosts are therefore recommended to avoid using these
          features, as it would be trivial for other authors to read the data
          and overwrite it.
        </p>

        <aside class="note">Even if a path-restriction feature was made
          available, the usual DOM scripting security model would make it
          trivial to bypass this protection and access the data from any
          path.
        </aside>
      </section>

      <section id="implementation-risks" class="section">
        <h3>Implementation risks</h3>

        <p>The two primary risks when implementing these persistent storage
        features are letting hostile sites read information from other
        domains, and letting hostile sites write information that is then
        read from other domains.</p>

        <p>Letting third-party sites read data that is not supposed to be
        read from their domain causes <em>information leakage</em>, For
        example, a user's shopping wish list on one domain could be used by
        another domain for targeted advertising; or a user's
        work-in-progress confidential documents stored by a word-processing
        site could be examined by the site of a competing company.</p>

        <p>Letting third-party sites write data to the persistent storage of
        other domains can result in <em>information spoofing</em>, which is
        equally dangerous. For example, a hostile site could add records to a
        user's wish list; or a hostile site could set a user's session
        identifier to a known ID that the hostile site can then use to track
        the user's actions on the victim site.</p>

        <p>Thus, strictly following the <span>origin</span> model described
        in this specification is important for user security.</p>
      </section>
    </section> <!-- authorization -->

    <section class="appendix section" id="requirements">
      <h2>Requirements</h2>
      <div class="ednote">
        Requirements will be written with an aim to verify that these were actually
        met by the API specified in this document.
      </div>
    </section>
    <section class="appendix section" id="revision-history">
      <h2>Revision History</h2>
      <p>
        The following is an informative summary of the changes since the last
        publication of this specification.
        A complete revision history can be found
        <a href="https://github.com/w3c/IndexedDB/">here</a>.
        For the revision history of the First Edition, see
        <a href="http://www.w3.org/TR/IndexedDB/#revision-history">that
          document's Revision History</a>.
      </p>
      <ul>
        <li>Address comparison of empty arrays (<a href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=27712">bug #27712</a>)</li>
        <li>Add <code>openKeyCursor</code> method to <a>IDBObjectStore</a>.
          (<a href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=19955">bug #19955</a>)
        </li>
        <li>Correct <var>source</var> used for <code>get()</code>,
          <code>getKey()</code> and <code>openKeyCursor()</code> operations of
          <a>IDBIndex</a> objects.
        </li>
        <li>Added details around garbage collection of <a>IDBDatabase</a> objects (<a href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=25223">bug #25223</a>)</li>
        <li>Added <code>[Exposed=(Window,Worker)]</code> annotations to interfaces.</li>
        <li>Added <var>forced flag</var> to the <a>steps for closing a database connection</a>,
          described the firing of a "<code>close</code>" event, and added <code>onclose</code>
          event handler definition for <a>IDBDatabase</a>.
          (<a href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=22540">bug #22540</a>)</li>
        <li>Converted specification to a more algorithmic style,
          and define abstract types such as <a>key</a> more rigorously.
          (<a href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=17681">bug #17681</a>)</li>
        <li>Added <code>getAll</code> and <code>getAllKeys</code> methods to
          <a>IDBObjectStore</a> and <a>IDBIndex</a>.
          (<a href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=16595">bug #16595</a>)</li>
        <li>Replaced <code>DOMError</code> with <code>DOMException</code>.
          (<a href="https://github.com/w3c/IndexedDB/issues/16">bug #16</a>)</li>
        <li>Added <code>objectStoreNames</code> attribute to <a>IDBTransaction</a>.
          (<a href="https://github.com/w3c/IndexedDB/issues/18">bug #18</a>)</li>
        <li>Added <i>binary</i> <a title="key">keys</a>, including comparisons and ECMAScript bindings.
          (<a href="https://github.com/w3c/IndexedDB/issues/21">bug #21</a>)</li>
        <li>Allow renaming stores and indexes.
          (<a href="https://github.com/w3c/IndexedDB/issues/21">bug #22</a>)</li>
        <li>Add <code>continuePrimaryKey</code> to <a>IDBCursor</a>
          (<a href="https://github.com/w3c/IndexedDB/issues/14">bug #14</a>)</li>
      </ul>
    </section>
    <section class="section appendix" id="acknowledgements">
      <h2>Acknowledgements</h2>
      <div>
      	<p>
      	  Special thanks to Nikunj Mehta, the original author of
          the first edition, and Jonas Sicking, Eliot Graff, Andrei Popescu,
          and Jeremy Orlow, additional editors of the First Edition.
      	</p>
	<p>
	  Garret Swart was extremely influential in the design of this specification.
	</p>
	<p>
			Special thanks to
                        Chris Anderson,
                        Pablo Castro,
                        Kristof Degrave,
                        Jake Drew,
                        Ben Dilts,
                        Jo&atilde;o Eiras:
                        Alec Flett,
                        Dana Florescu,
                        David Grogan,
                        Israel Hilerio,
                        Kyle Huey,
                        Laxminarayan G Kamath A,
                        Anne van Kesteren,
                        Adam Klein,
                        Tobie Langel,
                        Kang-Hao Lu,
                        Andrea Marchesini,
                        Glenn Maynard,
                        Ms2ger,
                        Odin Omdal,
                        Danillo Paiva,
                        Olli Pettay,
                        Simon Pieters,
                        Yonathan Randolph,
                        Arun Ranganathan,
                        Margo Seltzer,
                        Maciej Stachowiak,
                        Ben Turner,
                        Kyaw Tun,
                        Hans Wennborg,
                        Shawn Wilsher,
                        Boris Zbarsky
                        Zhiqiang Zhang,
                        and
                        Kris Zyp,
			all of whose feedback and suggestions have led to improvements to this specification.
		</p>
      </div>
    </section>
  </body>
</html>
